Object subclass: #GestorEmpleos	instanceVariableNames: 'colPostulantes colEmpresasSolicitantes colPropuestas diaActual'	classVariableNames: ''	package: 'TPFinalObligatorio'!!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/24/2022 03:38'!listarSolicitudesPendientesRegistradas: unaFecha	| colSolicitudesPendientes |	colSolicitudesPendientes := SortedCollection		                            new;		                            sortBlock: [ :solA :solB | 			                            solA getFechaRegistro			                            < solB getFechaRegistro ].colEmpresasSolicitantes collect: [ :unaEmpresa | unaEmpresa getSolicitudesPendientesRegistradas: unaFecha ] into: colSolicitudesPendientes .^colSolicitudesPendientes ! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 19:14'!aceptarPropuesta: unaPropuestaAceptada	| solicitudPropuesta unaEmpresaSolicitante |	solicitudPropuesta := unaPropuestaAceptada getSolicitud.	"Elimino propuestas que contengan la solicitud aceptada"	colPropuestas := colPropuestas reject: [ :unaPropuesta | 		                 unaPropuesta contieneSolicitud: solicitudPropuesta ].	unaEmpresaSolicitante  := self getEmpresaSol: solicitudPropuesta.	unaEmpresaSolicitante  marcarResuelta: solicitudPropuesta! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 20:58'!iniciarDia"Metodo que simula el pasar de un dia, elimina solicitudes vencidas (tambien las propuestas correspondientes a ellas) y marca las que se vencieron en el dia actual."|colSolicitudesEliminadas|colSolicitudesEliminadas := OrderedCollection new.diaActual := diaActual  addDays: 1."Elimino solicitudes vencidas y marco como vencidas las que vencen 'hoy' "colEmpresasSolicitantes do: [ :unaEmpresa | colSolicitudesEliminadas addAll: (unaEmpresa eliminarSolicitudesVencidas).	unaEmpresa marcarSolicitudesVencidas: diaActual  ]."Elimino propuestas usando colSolicitudesEliminadas"colSolicitudesEliminadas do: [:unaSolicitud |colPropuestas removeAllSuchThat: [ :unaPropuesta | unaPropuesta tieneSolicitud: unaSolicitud  ]]! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/24/2022 03:32'!listarSolicitudesPendientes: unaEmpresa"Lista las solicitudes pendientes de una empresa pasada por parametro"^unaEmpresa getSolicitudesPendientes.! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 17:42'!getEmpresaSol: unaSolicitud|empresa|empresa :=	colEmpresasSolicitantes select: [ :unaEmpresa | 		  unaEmpresa tieneSolicitud: unaSolicitud ].	^empresa ! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/24/2022 03:31'!generarPropuestasPendientes	"Mensaje que genera propuestas para las solicitudes pendientes"	| colSolPendientes |	"Se crea la coleccion y se le pasa un bloque para ordenar las solicitudes por fecha. (+antigua a -antigua)"	colSolPendientes := SortedCollection		                    new;		                    sortBlock: [ :solicitudA :solicitudB | 			                    solicitudA getFechaRegistro			                    < solicitudB getFechaRegistro ].	"Aca se obtienen las solicitudes pendientes de la coleccion de empresas"	colSolPendientes addAll:		(colEmpresasSolicitantes collect: [ :unaEmpresa | 			 unaEmpresa getSolicitudesPendientes ]).	colSolPendientes do: [ :unaSolicitud | 		colPostulantes do: [ :unPostulante | 			(unaSolicitud verificarPostulanteValido: unPostulante) ifTrue: [ 				:unaPropuesta | 				unaPropuesta					crearConSolicitud: unaSolicitud					conPostulante: unPostulante.				colPropuestas					detect: [ :cadaUnaPropuesta | 					cadaUnaPropuesta esIgual: unaPropuesta ]					ifNone: [ colPropuestas add: unaPropuesta ] ] ] ]! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/24/2022 03:50'!listarEmpresasSolResueltas^ colEmpresasSolicitantes sorted: [ :emp1 :emp2 | (emp1 getCantidadSolResueltas )> (emp2 getCantidadSolResueltas)  ]! !Object subclass: #Postulante	instanceVariableNames: 'nombre email telefono idPostulante'	classVariableNames: ''	package: 'TPFinalObligatorio'!!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 12:25'!noSuperaMaximo: unMontoself subclassResponsibility ! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 14:23'!tieneProducto: productoSolicitado	^ false! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 19:15'!esFraude: unaSolicitud^false! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 14:23'!esCombinada	^ false! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/20/2022 02:31'!esAptoTrabajo: unCargo"Mensaje que responde false"^false! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 14:21'!esPuntual ^ true! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/20/2022 03:03'!esAptoServicio: unServicioself subclassResponsibility ! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 14:23'!esProlongado ^false! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 17:06'!esIgual: unPostulante^idPostulante = unPostulante getId ! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 17:06'!getId ^idPostulante ! !Postulante subclass: #Empresa	instanceVariableNames: 'rubro rango servicioProvisto'	classVariableNames: 'MAXIMO'	package: 'TPFinalObligatorio'!!Empresa methodsFor: 'as yet unclassified' stamp: 'Ulises 2/20/2022 03:05'!esAptoServicio: unServicio^servicioProvisto = unServicio ! !!Empresa methodsFor: 'as yet unclassified' stamp: 'Ulises 2/24/2022 03:32'!getSolicitudesPendientes ^nil! !!Empresa methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 13:29'!noSuperaMaximo: unMonto	^ unMonto <= MAXIMO * rango! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Empresa class	instanceVariableNames: ''!!Empresa class methodsFor: 'initialization' stamp: 'Ulises 2/21/2022 12:47'!setMaximo: unValor	MAXIMO := unValor ! !!Empresa class methodsFor: 'initialization' stamp: 'Ulises 2/21/2022 12:47'!getMaximo	^MAXIMO ! !Empresa subclass: #EmpresaCombinada	instanceVariableNames: 'colProductos'	classVariableNames: ''	package: 'TPFinalObligatorio'!!EmpresaCombinada methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 14:21'!esPuntual	^ false! !!EmpresaCombinada methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 14:27'!tieneProducto: productoSolicitado^ colProductos anySatisfy: [ :unProducto | unProducto = productoSolicitado  ]! !Empresa subclass: #EmpresaSolicitante	instanceVariableNames: 'colSolicitud colSolicitudesResueltas'	classVariableNames: ''	package: 'TPFinalObligatorio'!!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 19:27'!esFraude: unaSolicitud^ colSolicitud anySatisfy: [ :cadaUnaSolicitud | cadaUnaSolicitud esIgual: unaSolicitud  ]! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/22/2022 00:11'!eliminarSolicitudesVencidas	"Elimina las solicitudes vencidas de la coleccion de solitudes y las retorna"	| solicitudesVencidas |	solicitudesVencidas := colSolicitud select: [ :unaSolicitud | 		                       unaSolicitud estaVencida ].	colSolicitud removeAll: solicitudesVencidas.	^solicitudesVencidas ! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/24/2022 03:30'!getSolicitudesPendientes	"Metodo que devuelve una coleccion con las solicitudes que no estan vencidas"	| colSolicitudesPendientes |	^ colSolicitudesPendientes := colSolicitud reject: [ :unaSolicitud | 		                              unaSolicitud estaVencida ]! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/22/2022 00:31'!marcarSolicitudesVencidas: diaActual	colSolicitud		do: [ :unaSolicitud | 			(unaSolicitud verificarVencimiento: diaActual) ifTrue: [ 				unaSolicitud setEstado: $V ] ]		! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/24/2022 03:43'!getSolicitudesPendientesRegistradas: unaFecha ^  colSolicitud select: [ :unaSolicitud | unaSolicitud estaRegistradaFecha: unaFecha ]! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/24/2022 03:51'!getCantidadSolResueltas^colSolicitudesResueltas size! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 19:14'!marcarResuelta: unaSolicitud	colSolicitud := colSolicitud remove: [ :cadaUnaSolicitud | 		                cadaUnaSolicitud esIgual: unaSolicitud ].	colSolicitudesResueltas add: ( unaSolicitud setEstado: $R) ! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 14:21'!esPuntual	^ false! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 17:37'!tieneSolicitud: unaSolicitud^ colSolicitud anySatisfy: [ :cadaUnaSolicitud | cadaUnaSolicitud esIgual: unaSolicitud  ]! !Empresa subclass: #EmpresaUniforme	instanceVariableNames: ''	classVariableNames: ''	package: 'TPFinalObligatorio'!!EmpresaUniforme methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 14:21'!esPuntual	^ false	! !!EmpresaUniforme methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 14:24'!esProlongado ^true! !Postulante subclass: #Persona	instanceVariableNames: 'colAptitud'	classVariableNames: 'MAXIMO_INDIVIDUAL'	package: 'TPFinalObligatorio'!!Persona methodsFor: 'as yet unclassified' stamp: 'Ulises 2/20/2022 03:04'!esAptoServicio: unServicio^colAptitud anySatisfy: [ :unaAptitud | unaAptitud = unServicio ]! !!Persona methodsFor: 'as yet unclassified' stamp: 'Ulises 2/20/2022 02:34'!esAptoTrabajo: unCargo^ colAptitud anySatisfy: [ :unaAptitud | unaAptitud = unCargo  ]! !!Persona methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 14:24'!esProlongado ^true! !!Persona methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 13:31'!noSuperaMaximo: unMonto^ unMonto <= MAXIMO_INDIVIDUAL ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Persona class	instanceVariableNames: ''!!Persona class methodsFor: 'initialization' stamp: 'Ulises 2/21/2022 13:32'!getMaximoIndividual^	MAXIMO_INDIVIDUAL ! !!Persona class methodsFor: 'initialization' stamp: 'Ulises 2/21/2022 13:32'!setMaximoIndividual: unValorMAXIMO_INDIVIDUAL := unValor ! !Object subclass: #Propuesta	instanceVariableNames: 'solicitudPropuesta postulantePropuesta'	classVariableNames: ''	package: 'TPFinalObligatorio'!!Propuesta methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 13:45'!inicializarConSolicitud: unaSolicitud conPostulante: unPostulante solicitudPropuesta := unaSolicitud .postulantePropuesta := unPostulante ! !!Propuesta methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 17:00'!getSolicitud^ solicitudPropuesta ! !!Propuesta methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 17:04'!esIgual: unaPropuesta	^ (solicitudPropuesta esIgual:  unaPropuesta getSolicitud)	  & (postulantePropuesta esIgual: unaPropuesta getPostulante)! !!Propuesta methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 17:31'!contieneSolicitud: unaSolicitud"Mensaje que retorna un boolean dependiendo si la propuesta contiene o no la solicitud mandada por parametro"^ solicitudPropuesta esIgual: unaSolicitud ! !!Propuesta methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 17:03'!getPostulante ^postulantePropuesta ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Propuesta class	instanceVariableNames: ''!!Propuesta class methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 13:47'!crearConSolicitud: unaSolicitud conPostulante: unPostulante	| unaPropuesta |	unaPropuesta := self		                new.		unaPropuesta 		             inicializarConSolicitud: unaSolicitud		                conPostulante: unPostulante.	^ unaPropuesta! !Object subclass: #Solicitud	instanceVariableNames: 'idSolicitud fechaRegistro fechaVencimiento monto estado'	classVariableNames: ''	package: 'TPFinalObligatorio'!!Solicitud methodsFor: 'as yet unclassified' stamp: 'Ulises 2/20/2022 01:43'!verificarPostulanteValido: unPostulante"Metodo polimorfico que verifica que un postulante sea valido para la solicitud a la que se le manda el msj"self subclassResponsibility ! !!Solicitud methodsFor: 'as yet unclassified' stamp: 'Ulises 2/22/2022 00:39'!verificarVencimiento: diaActual	"Verifica si la solicitud esta vencida al dia de 'hoy' y retorna un boolean"	^ (fechaVencimiento subtractDate:  diaActual) = 0! !!Solicitud methodsFor: 'as yet unclassified' stamp: 'Ulises 2/19/2022 18:08'!getFechaRegistro"retorna la fecha registrada"^fechaRegistro ! !!Solicitud methodsFor: 'as yet unclassified' stamp: 'Ulises 2/19/2022 19:27'!estaVencida^estado = $V! !!Solicitud methodsFor: 'as yet unclassified' stamp: 'Ulises 2/24/2022 03:44'!estaRegistradaFecha: unaFecha^ fechaRegistro equals: unaFecha ! !!Solicitud methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 17:05'!esIgual: unaSolicitud^idSolicitud = unaSolicitud getId.! !!Solicitud methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 17:06'!getId ^idSolicitud ! !!Solicitud methodsFor: 'initialization' stamp: 'Ulises 2/21/2022 19:06'!setEstado: unaLetraestado := unaLetra ! !Solicitud subclass: #DeServicio	instanceVariableNames: 'servicio caracteristicas'	classVariableNames: ''	package: 'TPFinalObligatorio'!!DeServicio methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 13:32'!verificarPostulanteValido: unPostulante	| respuesta |	respuesta := false.	(unPostulante esAptoServicio: servicio) ifTrue: [ 		respuesta := unPostulante noSuperaMaximo: monto ].	^ respuesta! !Solicitud subclass: #DeTrabajo	instanceVariableNames: 'descripcion cargo'	classVariableNames: ''	package: 'TPFinalObligatorio'!!DeTrabajo methodsFor: 'as yet unclassified' stamp: 'Ulises 2/20/2022 02:30'!verificarPostulanteValido: unPostulante	"Mensaje que responde si el postulante pasado por parametro es apto para el trabajo"^ unPostulante esAptoTrabajo: cargo.! !DeServicio subclass: #Prolongado	instanceVariableNames: 'duracion formaPago'	classVariableNames: ''	package: 'TPFinalObligatorio'!!Prolongado methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 13:54'!verificarPostulanteValido: unPostulante	| respuesta |	respuesta := false.	(unPostulante esProlongado) ifTrue: [ 		respuesta := super verificarPostulanteValido: unPostulante ].	^ respuesta! !DeServicio subclass: #Puntual	instanceVariableNames: ''	classVariableNames: ''	package: 'TPFinalObligatorio'!!Puntual methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 13:54'!verificarPostulanteValido: unPostulante	| respuesta |	respuesta := false.	(unPostulante esPuntual) ifTrue: [ 		respuesta := super verificarPostulanteValido: unPostulante ].	^ respuesta! !BorderedMorph subclass: #TestVisual	instanceVariableNames: 'botonPostulantes botonPropuestas botonSolicitantes botonCerrar botonMinimizar'	classVariableNames: ''	package: 'TPFinalObligatorio'!DeServicio subclass: #YProducto	instanceVariableNames: 'productoSolicitado'	classVariableNames: ''	package: 'TPFinalObligatorio'!!YProducto methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 14:26'!verificarPostulanteValido: unPostulante	| respuesta |	respuesta := false.	unPostulante esCombinada ifTrue: [ 		(unPostulante			tieneProducto: productoSolicitado)			ifTrue: [ 			respuesta := super verificarPostulanteValido: unPostulante ] ].	^ respuesta! !