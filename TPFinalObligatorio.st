BorderedMorph subclass: #BarraVentana	instanceVariableNames: 'botonCerrar botonMinimizar titulo'	classVariableNames: ''	package: 'TPFinalObligatorio'!!BarraVentana methodsFor: 'as yet unclassified' stamp: 'Ulises 2/25/2023 23:44'!inicializar	"Metodo que crea una barra para las ventanas usando layoutPolicy para posicionar sus elementos"	self		initialize;		borderColor: Color transparent;		color: Color gray.	self layoutPolicy: TableLayout new.	self		listDirection: #leftToRight;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		wrapDirection: #topToButtom;		layoutInset: 2;		cellInset: 2.	"Se inicializan los botones"	botonCerrar := Boton newWithLabel: 'X'.	botonMinimizar := Boton newWithLabel: '_'.	"Le agrego los morphs a la barra"	self addMorph: botonMinimizar.	self addMorph: botonCerrar.	"Aniado caracteristicas a los morphs"	botonCerrar		color: self color;		width: botonCerrar height.	botonMinimizar		color: self color;		width: botonCerrar height.	"Aniado funcionalidad a los botones"	botonCerrar mouseAction: [ self accionBotonCerrar ].	botonMinimizar mouseAction: [ self owner collapse ]! !!BarraVentana methodsFor: 'as yet unclassified' stamp: 'Torgeck 12/18/2022 04:02'!agregarTitulo: unTitulo	| contenedor tituloMorph |	contenedor := Morph new.	contenedor layoutPolicy: TableLayout new.	contenedor		listDirection: #topToBottom;		listCentering: #center;		wrapCentering: #center;		hResizing: #spaceFill;		beTransparent;		vResizing: #shrinkWrap.	tituloMorph := StringMorph new		               contents: unTitulo;		               color: Color white.	contenedor addMorph: tituloMorph.	^ contenedor! !!BarraVentana methodsFor: 'as yet unclassified' stamp: 'Ulises 2/26/2023 01:09'!inicializarConTitulo: unTitulo	"Metodo que crea una barra para las ventanas usando layoutPolicy para posicionar sus elementos"		self		initialize;		borderColor: self getColor ;		color: self getColor .	self layoutPolicy: TableLayout new.	self		listDirection: #rightToLeft;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		wrapDirection: #topToButtom;		layoutInset: 2;		cellInset: 2.	"Se inicializan los botones"	botonCerrar := Boton newWithLabel: 'X'.	botonMinimizar := Boton newWithLabel: '_'.	titulo := self agregarTitulo: unTitulo.	"Le agrego los morphs a la barra"	self addMorph: botonCerrar.	self addMorph: botonMinimizar.	self addMorph: titulo.	"Aniado caracteristicas a los morphs"	botonCerrar		color: self color;		width: botonCerrar height.	botonMinimizar		color: self color;		width: botonCerrar height.	"Aniado funcionalidad a los botones"	botonCerrar mouseAction: [ self accionBotonCerrar ].	botonMinimizar mouseAction: [ self owner collapse ]! !!BarraVentana methodsFor: 'as yet unclassified' stamp: 'Ulises 2/26/2023 01:09'!getColor^Color fromHexString: '44546B'! !!BarraVentana methodsFor: 'as yet unclassified' stamp: 'Ulises 1/31/2023 00:31'!accionBotonCerrar	(UIManager default		        proceed: 'Quiere cerrar la ventana?'		        title: 'ATENCION') ifTrue: [ self owner delete ]! !!BarraVentana methodsFor: 'initialization' stamp: 'Torgeck 12/27/2022 01:36'!setTitulo: unTitulo"Mensaje que setea el titulo de la barraVentana"titulo ! !SimpleButtonMorph subclass: #Boton	instanceVariableNames: 'bloqueAccion mouseAction'	classVariableNames: ''	package: 'TPFinalObligatorio'!!Boton methodsFor: 'event handling' stamp: 'Torgeck 11/22/2022 20:16'!mouseUp: unEvento	super mouseUp: unEvento.	bloqueAccion value! !!Boton methodsFor: 'initialization' stamp: 'Ulises 2/26/2023 01:12'!initialize	super initialize.	self fillStyle:		(SolidFillStyle color: (Color fromHexString: '44546B'));		borderColor: Color transparent ! !!Boton methodsFor: 'accessing' stamp: 'Torgeck 11/22/2022 20:16'!mouseAction: unBloque	^ bloqueAccion := unBloque! !FTSimpleDataSource subclass: #FTGestorEmpleosDataSource	instanceVariableNames: ''	classVariableNames: 'nombres'	package: 'TPFinalObligatorio'!!FTGestorEmpleosDataSource methodsFor: 'accessing' stamp: 'Ulises 2/3/2023 18:37'!cellColumn: column row: rowIndex	column id = 'Coleccion' ifTrue: [ 		^ self coleccion: column row: rowIndex ].	column id = 'Cantidad' ifTrue: [ 		^ self cantidad: column row: rowIndex ].	self error: 'Invalid column'! !!FTGestorEmpleosDataSource methodsFor: 'accessing' stamp: 'Ulises 2/3/2023 21:39'!coleccion: column row: rowIndex	^ FTCellMorph new		  color: Color transparent;		  cellInset: 5;		withTopSeparator ;		  addMorphBack: (nombres at: rowIndex) asStringMorph;		  yourself! !!FTGestorEmpleosDataSource methodsFor: 'accessing' stamp: 'Ulises 2/25/2023 23:44'!cantidad: column row: rowIndex	^ FTCellMorph new		  color: Color transparent;		  cellInset: 5;		  listCentering: #center; withTopSeparator;		  addMorphBack: (self elementAt: rowIndex) size asStringMorph;		  yourself! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FTGestorEmpleosDataSource class	instanceVariableNames: ''!!FTGestorEmpleosDataSource class methodsFor: 'accessing' stamp: 'Ulises 2/3/2023 21:20'!elements: aCollection	nombres := OrderedCollection with: 'Postulantes' with: 'Propuestas' with: 'Empresas solicitantes' . 	^ self new elements: aCollection! !FTSimpleDataSource subclass: #FTPostulantesDataSource	instanceVariableNames: ''	classVariableNames: ''	package: 'TPFinalObligatorio'!!FTPostulantesDataSource methodsFor: 'accessing' stamp: 'Ulises 2/9/2023 16:03'!cellColumn: column row: rowIndex	column id = 'ID' ifTrue: [ 		^ self id: column row: rowIndex ].	column id = 'Nombre' ifTrue: [ ^ self nombre: column row: rowIndex ].	column id = 'Tipo' ifTrue: [ ^ self tipo: column row: rowIndex ].	self error: 'Invalid column'! !!FTPostulantesDataSource methodsFor: 'as yet unclassified' stamp: 'Ulises 2/25/2023 23:54'!id: column row: rowIndex	^ FTCellMorph new		  color: Color transparent;		  cellInset: 5;		  listCentering: #center;		  withTopSeparator;		  addMorphBack: (self elementAt: rowIndex) getId asStringMorph;		  yourself! !!FTPostulantesDataSource methodsFor: 'as yet unclassified' stamp: 'Ulises 2/25/2023 23:55'!tipo: column row: rowIndex	^ FTCellMorph new		  color: Color transparent;		  cellInset: 5;		listCentering: #center;		  withTopSeparator;		  addMorphBack: (self elementAt: rowIndex) getTipo asStringMorph;		  yourself! !!FTPostulantesDataSource methodsFor: 'as yet unclassified' stamp: 'Ulises 2/25/2023 23:59'!nombre: column row: rowIndex	^ FTCellMorph new		  color: Color transparent;		  cellInset: 5;		listCentering: #center;		  withTopSeparator;		  addMorphBack: (self elementAt: rowIndex) getNombre asStringMorph;		  yourself! !FTPostulantesDataSource subclass: #FTEmpresasSolicitantesDataSource	instanceVariableNames: ''	classVariableNames: ''	package: 'TPFinalObligatorio'!!FTEmpresasSolicitantesDataSource methodsFor: 'as yet unclassified' stamp: 'Ulises 2/25/2023 23:57'!numSolResueltas: column row: rowIndex	^ FTCellMorph new		  color: Color transparent;		  cellInset: 5;		  withTopSeparator;		listCentering: #center;		  addMorphBack:			  (self elementAt: rowIndex) getCantidadSolResueltas asStringMorph;		  yourself! !!FTEmpresasSolicitantesDataSource methodsFor: 'as yet unclassified' stamp: 'Ulises 2/25/2023 23:57'!numSolicitudes: column row: rowIndex	^ FTCellMorph new		  color: Color transparent;		  cellInset: 5;		listCentering: #center;		  withTopSeparator;		  addMorphBack:			  (self elementAt: rowIndex) getColSolicitudes size asStringMorph;		  yourself! !!FTEmpresasSolicitantesDataSource methodsFor: 'accessing' stamp: 'Ulises 2/9/2023 17:01'!cellColumn: column row: rowIndex	"Ver si es conveniente usar o no herencia"	column id = 'ID' ifTrue: [ ^ self id: column row: rowIndex ].	column id = 'Nombre' ifTrue: [ ^ self nombre: column row: rowIndex ].	column id = 'Tipo' ifTrue: [ ^ self tipo: column row: rowIndex ].	column id = 'N° Solicitudes' ifTrue: [ 		^ self numSolicitudes: column row: rowIndex ].	column id = 'N° Solicitudes resueltas' ifTrue: [ 		^ self numSolResueltas: column row: rowIndex ].	super cellColumn: column row: rowIndex! !FTSimpleDataSource subclass: #FTPropuestasDataSource	instanceVariableNames: ''	classVariableNames: ''	package: 'TPFinalObligatorio'!!FTPropuestasDataSource methodsFor: 'accessing' stamp: 'Ulises 2/26/2023 00:16'!vencimiento: column row: rowIndex	^ FTCellMorph new		  color: Color transparent;		  cellInset: 5;		listCentering: #center;		  withTopSeparator;		  addMorphBack:			  (self elementAt: rowIndex) getSolicitud getFechaVencimiento				  asStringMorph;		  yourself! !!FTPropuestasDataSource methodsFor: 'accessing' stamp: 'Ulises 2/27/2023 15:42'!monto: column row: rowIndex	^ FTCellMorph new		  color: Color transparent;		  cellInset: 5;		  listCentering: #center;		  withTopSeparator;		  addMorphBack:			 ( '$ ' , (self elementAt: rowIndex) getSolicitud getMonto asString) asStringMorph;		  yourself! !!FTPropuestasDataSource methodsFor: 'accessing' stamp: 'Ulises 2/24/2023 00:09'!cellColumn: column row: rowIndex	"Ver si es conveniente usar o no herencia"	column id = 'Descripcion Solicitud' ifTrue: [ 		^ self descripcion: column row: rowIndex ].	column id = 'Monto' ifTrue: [ ^ self monto: column row: rowIndex ].	column id = 'Postulante' ifTrue: [ 		^ self postulante: column row: rowIndex ].	column id = 'Tipo' ifTrue: [ ^ self tipo: column row: rowIndex ].	column id = 'Fecha de registro' ifTrue: [ 		^ self fechaRegistro: column row: rowIndex ].	column id = 'Vencimiento' ifTrue: [ 		^ self vencimiento: column row: rowIndex ].	self error: 'Invalid column'! !!FTPropuestasDataSource methodsFor: 'accessing' stamp: 'Ulises 2/26/2023 00:15'!fechaRegistro: column row: rowIndex	^ FTCellMorph new		  color: Color transparent;		  cellInset: 5;		listCentering: #center;		  withTopSeparator;		  addMorphBack:			  (self elementAt: rowIndex) getSolicitud getFechaRegistro				  asStringMorph;		  yourself! !!FTPropuestasDataSource methodsFor: 'accessing' stamp: 'Ulises 2/24/2023 00:01'!descripcion: column row: rowIndex^ FTCellMorph new		  color: Color transparent;		  cellInset: 5;		  withTopSeparator;		  addMorphBack: (self elementAt: rowIndex) getSolicitud toString asStringMorph;		  yourself! !!FTPropuestasDataSource methodsFor: 'as yet unclassified' stamp: 'Ulises 2/26/2023 00:15'!postulante: column row: rowIndex	^ FTCellMorph new		  color: Color transparent;		  cellInset: 5;		listCentering: #center;		  withTopSeparator;		  addMorphBack:			  (self elementAt: rowIndex) getPostulante getNombre asStringMorph;		  yourself! !!FTPropuestasDataSource methodsFor: 'as yet unclassified' stamp: 'Ulises 2/26/2023 00:15'!tipo: column row: rowIndex	^ FTCellMorph new		  color: Color transparent;		  cellInset: 5;		listCentering: #center;		  withTopSeparator;		  addMorphBack:			  (self elementAt: rowIndex) getSolicitud getTipo asStringMorph;		  yourself! !FTSimpleDataSource subclass: #FTSolicitudesDataSource	instanceVariableNames: ''	classVariableNames: ''	package: 'TPFinalObligatorio'!!FTSolicitudesDataSource methodsFor: 'accessing' stamp: 'Ulises 2/26/2023 00:10'!estado: column row: rowIndex	^ FTCellMorph new		  color: Color transparent;		  cellInset: 5;		listCentering: #center;		  withTopSeparator;		  addMorphBack: (self elementAt: rowIndex) getEstado asStringMorph;		  yourself! !!FTSolicitudesDataSource methodsFor: 'accessing' stamp: 'Ulises 2/26/2023 00:11'!tipo: column row: rowIndex	^ FTCellMorph new		  color: Color transparent;		  cellInset: 5;		listCentering: #center;		  withTopSeparator;		  addMorphBack: (self elementAt: rowIndex) getTipo asStringMorph;		  yourself! !!FTSolicitudesDataSource methodsFor: 'accessing' stamp: 'Ulises 2/26/2023 00:11'!monto: column row: rowIndex	^ FTCellMorph new		  color: Color transparent;		  cellInset: 5;		listCentering: #center;		  withTopSeparator;		  addMorphBack:			  ('$ ' , (self elementAt: rowIndex) getMonto asString)				  asStringMorph;		  yourself! !!FTSolicitudesDataSource methodsFor: 'accessing' stamp: 'Ulises 2/6/2023 23:19'!cellColumn: column row: rowIndex	"Ver si es conveniente usar o no herencia"	column id = 'Descripcion' ifTrue: [ 		^ self descripcion: column row: rowIndex ].	column id = 'Estado' ifTrue: [ 		^ self estado: column row: rowIndex ].	column id = 'Monto' ifTrue: [ 		^ self monto: column row: rowIndex ].	column id = 'Tipo' ifTrue: [ 		^ self tipo: column row: rowIndex ].	column id = 'Fecha registro' ifTrue: [ 		^ self fechaRegistro: column row: rowIndex ].	column id = 'Fecha vencimiento' ifTrue: [ 		^ self fechaVencimiento: column row: rowIndex ].	self error: 'Invalid column'! !!FTSolicitudesDataSource methodsFor: 'accessing' stamp: 'Ulises 2/26/2023 00:11'!fechaRegistro: column row: rowIndex	^ FTCellMorph new		  color: Color transparent;		  cellInset: 5;		listCentering: #center;		  withTopSeparator;		  		  addMorphBack:			  (self elementAt: rowIndex) getFechaRegistro asStringMorph;		  yourself! !!FTSolicitudesDataSource methodsFor: 'accessing' stamp: 'Ulises 2/26/2023 00:11'!fechaVencimiento: column row: rowIndex	^ FTCellMorph new		  color: Color transparent;		  cellInset: 5;		listCentering: #center;		  withTopSeparator;		  addMorphBack:			  (self elementAt: rowIndex) getFechaVencimiento asStringMorph;		  yourself! !!FTSolicitudesDataSource methodsFor: 'accessing' stamp: 'Ulises 2/26/2023 00:09'!descripcion: column row: rowIndex	^ FTCellMorph new		  color: Color transparent;		  cellInset: 5;		  withTopSeparator;		  addMorphBack: (self elementAt: rowIndex) toString asStringMorph;		  yourself! !Object subclass: #GestorEmpleos	instanceVariableNames: 'colPostulantes colEmpresasSolicitantes colPropuestas diaActual'	classVariableNames: ''	package: 'TPFinalObligatorio'!!GestorEmpleos methodsFor: 'accessing' stamp: 'Torgeck 7/23/2022 17:13'!iniciarDia	"Metodo que simula el pasar de un dia, elimina solicitudes vencidas (tambien las propuestas correspondientes a ellas) y marca las que se vencieron en el dia actual."	| colSolicitudesEliminadas |	colSolicitudesEliminadas := OrderedCollection new.	diaActual := diaActual addDays: 1.		colEmpresasSolicitantes do: [ :unaEmpresa | 		colSolicitudesEliminadas addAll:			unaEmpresa eliminarSolicitudesVencidas.		unaEmpresa marcarSolicitudesVencidas: diaActual ].		colSolicitudesEliminadas do: [ :unaSolicitud | 		colPropuestas removeAllSuchThat: [ :unaPropuesta | 			unaPropuesta tieneSolicitud: unaSolicitud ] ]! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2023 22:30'!registrarEmpresaSolicitante: unNombre conRubro: unRubro conEmail: unEmail conTel: unTel	| respuesta |	respuesta := true.	"Verifico si existe solicitante"	(self existeSolicitante: unNombre)		ifTrue: [ respuesta := false ]		ifFalse: [ 			colEmpresasSolicitantes add: (EmpresaSolicitante					 crear: unNombre					 conRubro: unRubro					 conEmail: unEmail					 conTel: unTel) ].	^ respuesta! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/23/2022 17:25'!listarSolicitudesPendientesRegistradas: unaFecha	| colSolicitudesPendientes |	colSolicitudesPendientes := SortedCollection new.	colSolicitudesPendientes sort: [ :solA :solB | 		solA getFechaRegistro < solB getFechaRegistro ].	colSolicitudesPendientes addAll:		(colEmpresasSolicitantes flatCollect: [ :unaEmpresa | 			 unaEmpresa getSolicitudesPendientesRegistradas: unaFecha ]).	^ colSolicitudesPendientes! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/23/2023 23:24'!inicializar	Empresa setMaximo: 200000.	Persona setMaximoIndividual: 90000.	Postulante setID_CLASE: 0.	Solicitud setID_ACTUAL: 0.	colPostulantes := OrderedCollection new.	colEmpresasSolicitantes := OrderedCollection new.	colPropuestas := OrderedCollection new.	diaActual := Date today! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/20/2022 04:12'!inicializar: unaColEmp conPostulantes: unaColPos conPropuestas: unaColPro conDiaActual: unDiacolPostulantes := unaColPos .colEmpresasSolicitantes := unaColEmp .colPropuestas := unaColPro .diaActual := unDia ! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/3/2023 21:08'!getColPostulantes	^ colPostulantes ! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/24/2022 03:50'!listarEmpresasSolResueltas^ colEmpresasSolicitantes sorted: [ :emp1 :emp2 | (emp1 getCantidadSolResueltas )> (emp2 getCantidadSolResueltas)  ]! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/27/2023 22:21'!controlFraude	"Mensaje que realiza el control de fraude del gestor de empleos, retorna la cantidad de fraudes encontrados"	| cantidadFraudes |	cantidadFraudes := colPropuestas size.	colPropuestas removeAllSuchThat:  [ :unaPropuesta | 		                 unaPropuesta esFraude:			                 (self getEmpresaSol: unaPropuesta getSolicitud) ].	^ cantidadFraudes - colPropuestas size! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/22/2022 15:13'!getPropuestas^colPropuestas ! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/19/2022 02:46'!existePropuesta: unaSolicitud conPostulante: unPostulante^colPropuestas anySatisfy: [ :unaPropuesta | unaPropuesta esIgual: unaSolicitud conPostulante: unPostulante  ]! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 1/29/2023 22:20'!getEmpresaSolicitante: unNombre	| empresa |	empresa := colEmpresasSolicitantes		           detect: [ :unaEmpresa | 		           unaEmpresa getNombre = unNombre ]		           ifNone: [ nil ].	^ empresa! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2023 22:29'!registrarEmpresaPostulante: unNombre conRubro: unRubro conEmail: unEmail conTel: unTel conServ: unServ conProductos: unaColProductos conRango: unRango conPuntualidad: unaPuntualidad	| respuesta |	respuesta := true.	"Verifico si existe el postulante"	(self existePostulante: unNombre)		ifTrue: [ respuesta := false ]		ifFalse: [ 			colPostulantes add: (Empresa					 crear: unNombre					 conRubro: unRubro					 conEmail: unEmail					 conTel: unTel					 conServ: unServ					 conProductos: unaColProductos					 conRango: unRango					 conPuntualidad: unaPuntualidad) ].	^ respuesta! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/22/2023 02:11'!listarSolicitudesResueltas"Mensaje que obtiene una coleccion con todas las solicitudes resueltas del sistema"^colEmpresasSolicitantes flatCollect: [ :unaEmpresaSol | unaEmpresaSol getColSolicitudesResueltas  ]! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2023 22:26'!existeSolicitante: unAtributoClave	"Mensaje que retorna un boolean para saber si existe o no un postulante ya registrado en el sistema"	^ colEmpresasSolicitantes anySatisfy: [ :unSolicitante | 		  unSolicitante esIgual: unAtributoClave  ]! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2023 22:11'!existePostulante: unAtributoClave	"Mensaje que retorna un boolean para saber si existe o no un postulante ya registrado en el sistema"	^ colPostulantes anySatisfy: [ :unPostulante | 		  unPostulante esIgual: unAtributoClave ]! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/27/2023 17:48'!generarPropuestasPendientes	"Mensaje que genera propuestas para las solicitudes pendientes"	| colSolPendientes colPosiblesPostulantes |	"Se crea la coleccion y se le pasa un bloque para ordenar las solicitudes por fecha. (+antigua a -antigua)"	colSolPendientes := SortedCollection new.	colSolPendientes sortBlock: [ :solA :solB | 		solA getFechaRegistro < solB getFechaRegistro ].	"Aca se obtienen las solicitudes pendientes de la coleccion de empresas"	colSolPendientes addAll:		(colEmpresasSolicitantes flatCollect: [ :unaEmpresa | 			 unaEmpresa getSolicitudesPendientes ]).	"Ahora se empiezan a evaluar y generar las propuestas"	colSolPendientes ifNotEmpty: [ 		colSolPendientes do: [ :unaSolicitud | 			colPosiblesPostulantes := unaSolicitud obtenerPostulantesValidos:				                          colPostulantes.			colPosiblesPostulantes ifNotEmpty: [ 				colPosiblesPostulantes do: [ :unPostulante | 					(self existePropuesta: unaSolicitud conPostulante: unPostulante) 						ifFalse: [ 							colPropuestas add:								(Propuesta									 crearConSolicitud: unaSolicitud									 conPostulante: unPostulante) ] ] ] ] ]! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/22/2022 01:10'!getDiaActual^ diaActual ! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/3/2023 21:08'!getColPropuestas	^ colPropuestas ! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/3/2023 21:08'!getColSolicitantes	^ colEmpresasSolicitantes ! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2023 22:48'!registrarPersona: unNombre conEmail: unEmail conTel: unTel conDni: unDni conApellido: unApe conAptitud: unaColApt	"Mensaje que crea, verifica y registra una persona en el sistema"	| respuesta |	respuesta := true.	"Verifico si existe en el sistema"	(self existePostulante: unDni)		ifTrue: [ respuesta := false ]		ifFalse: [ 			colPostulantes add: (Persona					 crear: unNombre					 conEmail: unEmail									 conTel: unTel						conDni: unDni					 conApellido: unApe					 conAptitud: unaColApt) ].	^ respuesta! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/27/2023 23:16'!aceptarPropuesta: unaPropuestaAceptada	"Mensaje que checkea si la propuesta es un fraude, acepta si no lo es y cambia el estado de una propuesta pasada por parametro"	| solicitudPropuesta unaEmpresaSolicitante respuesta |	respuesta := false.	solicitudPropuesta := unaPropuestaAceptada getSolicitud.	unaEmpresaSolicitante := self getEmpresaSol: solicitudPropuesta.	(unaPropuestaAceptada esFraude: unaEmpresaSolicitante) ifFalse: [ 		"Elimino propuestas que contengan la solicitud aceptada"		colPropuestas := colPropuestas reject: [ :unaPropuesta | 			                 unaPropuesta tieneSolicitud: solicitudPropuesta ].		"Luego marca como resuelta la solicitud"		unaEmpresaSolicitante marcarResuelta: solicitudPropuesta.		respuesta := true ].	^ respuesta! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/24/2023 00:29'!getEmpresaSol: unaSolicitud	| empresa |	empresa := colEmpresasSolicitantes		           detect: [ :unaEmpresa | 		           unaEmpresa tieneSolicitud: unaSolicitud ]		     .	^ empresa! !!GestorEmpleos methodsFor: 'as yet unclassified' stamp: 'Ulises 2/24/2022 03:32'!listarSolicitudesPendientes: unaEmpresa"Lista las solicitudes pendientes de una empresa pasada por parametro"^unaEmpresa getSolicitudesPendientes.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GestorEmpleos class	instanceVariableNames: ''!!GestorEmpleos class methodsFor: 'as yet unclassified' stamp: 'Torgeck 12/12/2022 19:14'!crear	| unGestor |	unGestor := self new inicializar.	^ unGestor! !BorderedMorph subclass: #Menu	instanceVariableNames: 'botonSolicitudes botonEmpresasSolicitantes botonPostulantes botonCerrar'	classVariableNames: ''	package: 'TPFinalObligatorio'!!Menu methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/25/2022 04:27'!inicializarself initialize.self color: Color paleGreen.self position: 500 @ 500.self bounds: (self position extent: 1000 @ 500)."Se le agregan los botones de las opciones"botonSolicitudes := Boton new.botonEmpresasSolicitantes := Boton new.botonPostulantes := Boton new.botonCerrar := Boton new."Le agrego los botones al menu"self addMorph: botonSolicitudes .self addMorph: botonEmpresasSolicitantes .self addMorph: botonPostulantes .self addMorph: botonCerrar."Posiciono los botones"! !BorderedMorph subclass: #MenuBienvenidaMorph	instanceVariableNames: 'botonCargado botonVacio barraVentana texto origen'	classVariableNames: ''	package: 'TPFinalObligatorio'!!MenuBienvenidaMorph methodsFor: 'as yet unclassified' stamp: 'Torgeck 11/30/2022 02:15'!inicializar	"Metodo que inicializa el menu UI de gestor empleos"	self initialize.	self color: Color paleGreen.	self position: 500 @ 500.	self bounds: (self position extent: 200 @ 200).	"Se le da dos opciones y dependiendo cual boton aprete el usuario se crea un gestor pre-cargado o no "	botonCargado := Boton newWithLabel: 'Pre-cargado'.	botonVacio := Boton newWithLabel: 'Vacio'.	barraVentana := BarraVentana new.	texto := StringMorph new.	"Le agrego los morphs a MenuBienvenida"	self addMorph: botonCargado.	self addMorph: botonVacio.	self addMorph: barraVentana.	self addMorph: texto.	"Posiciono los botones dentro del area de MenuBienvenida"	barraVentana inicializarConTitulo: 'Menu Bienvenida'.	origen := self center.	botonCargado position: origen + (self extent * (-0.2 @ 0.2)).	botonVacio position: origen + (self extent * (-0.2 @ -0.1)).	texto position: self topLeft + (self extent * (0.2 @ 0.2)).	barraVentana		position: self topLeft.	"Aniado caracteristicas para los morphs"	texto		contents: 'Iniciar gestor empresa';		color: Color black.	botonVacio width: botonCargado width.	"Aniado funcionalidad a los botones"	botonVacio mouseAction: [ 		Menu			new;			inicializar.		self delete ].	botonCargado mouseAction: [ 		Menu inicializarCargado.		self delete ].	self openInWorld! !Object subclass: #Postulante	instanceVariableNames: 'nombre email telefono idPostulante'	classVariableNames: 'ID'	package: 'TPFinalObligatorio'!!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2023 13:31'!getAtributoClave	^ self subclassResponsibility ! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 14:23'!tieneProducto: productoSolicitado	^ false! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 17:06'!getId ^idPostulante ! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/20/2022 03:03'!esAptoServicio: unServicioself subclassResponsibility ! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/23/2022 01:55'!esAptoServicio: unServicio conPuntualidad: unaPuntualidad	self subclassResponsibility! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/20/2022 02:31'!esAptoTrabajo: unCargo"Mensaje que responde false"^false! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2023 22:10'!esIgual: unAtributoClave	^ self getAtributoClave = unAtributoClave ! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/20/2022 04:41'!inicializar: unNombre conEmail: unEmail conTel: unTel	nombre := unNombre.	email := unEmail.	telefono := unTel.	idPostulante := self generarId.! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/22/2023 01:17'!esEmpresa	^ false! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 1/29/2023 22:19'!getNombre^nombre! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 12:25'!noSuperaMaximo: unMontoself subclassResponsibility ! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/15/2022 03:23'!generarId|idGenerado|idGenerado :=  self class getID_CLASE.self class setID_CLASE: idGenerado + 1.^idGenerado .! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 14:23'!esCombinada	^ false! !!Postulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/4/2023 20:27'!getTipo	^ self className asString! !!Postulante methodsFor: 'printing' stamp: 'Torgeck 7/23/2022 00:22'!toString^nombre! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Postulante class	instanceVariableNames: ''!!Postulante class methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/15/2022 03:18'!setID_CLASE: unValor ID:= unValor.! !!Postulante class methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/15/2022 03:17'!getID_CLASE ^ID.! !Postulante subclass: #Empresa	instanceVariableNames: 'rubro rango servicioProvisto puntual colProductos'	classVariableNames: 'MAXIMO'	package: 'TPFinalObligatorio'!!Empresa methodsFor: 'initialization' stamp: 'Torgeck 7/22/2022 22:59'!setRango: unRangorango := unRango ! !!Empresa methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 12:48'!getTipo	| unTipo |	unTipo := self esPuntual				          ifTrue: [ ' Puntual' ]				          ifFalse: [ ' Uniforme' ].	unTipo := self esCombinada ifTrue: [ ' Combinada' , unTipo ] ifFalse: [ unTipo].	^ super getTipo , unTipo! !!Empresa methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/19/2022 02:43'!tieneProducto: unProducto"Mensaje que retorna true si la empresa combinada posee el producto pasado por parametro y false en caso contrario"^ colProductos anySatisfy:  [ :unProductoColProductos | unProductoColProductos = unProducto ]! !!Empresa methodsFor: 'as yet unclassified' stamp: 'Ulises 2/4/2023 22:40'!inicializar: unNombre conRubro: unRubro conEmail: unEmail conTel: unTel conServ: unServ conProductos: unaColProductos conRango: unRango conPuntualidad: unaPuntualidad	"ACA ESTA MAL TENGO QUE USAR EL INICIALIZADOR DE LA CLASE MADRE"	self inicializar: unNombre conEmail: unEmail conTel: unTel.	rubro := unRubro.	puntual := unaPuntualidad.	servicioProvisto := unServ.	colProductos := unaColProductos.	rango := unRango! !!Empresa methodsFor: 'as yet unclassified' stamp: 'Ulises 2/20/2022 03:05'!esAptoServicio: unServicio^servicioProvisto = unServicio ! !!Empresa methodsFor: 'as yet unclassified' stamp: 'Ulises 2/24/2022 03:32'!getSolicitudesPendientes ^nil! !!Empresa methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/19/2022 01:21'!esAptoServicio: unServicio conPuntualidad: unaPuntualidad"Mensaje que evalua si una empresa es apta para la solicitud de servicio y retorna un boolean como respuesta"^ servicioProvisto = unServicio and: [puntual = unaPuntualidad] .! !!Empresa methodsFor: 'as yet unclassified' stamp: 'Ulises 2/4/2023 22:39'!inicializar: unNombre conRubro: unRubro conEmail: unEmail conTel: unTel	"ACA ESTA MAL TENGO QUE USAR EL INICIALIZADOR DE LA CLASE MADRE"	self inicializar: unNombre conEmail: unEmail conTel: unTel.	rubro := unRubro.	puntual := false.	colProductos := OrderedCollection new.	servicioProvisto := nil.	rango := 1! !!Empresa methodsFor: 'as yet unclassified' stamp: 'Ulises 2/4/2023 20:38'!esPuntual 	^ puntual! !!Empresa methodsFor: 'as yet unclassified' stamp: 'Ulises 2/22/2023 01:17'!esEmpresa ^true.! !!Empresa methodsFor: 'as yet unclassified' stamp: 'Ulises 2/4/2023 22:40'!inicializar: unNombre conRubro: unRubro conEmail: unEmail conTel: unTel conServ: unServ	"ACA ESTA MAL TENGO QUE USAR EL INICIALIZADOR DE LA CLASE MADRE"	self inicializar: unNombre conEmail: unEmail conTel: unTel.	rubro := unRubro.	puntual := false.	colProductos := OrderedCollection new.	servicioProvisto := unServ.	rango := 1! !!Empresa methodsFor: 'as yet unclassified' stamp: 'Ulises 2/23/2023 23:13'!noSuperaMaximo: unMonto	^ unMonto <= (MAXIMO * rango)! !!Empresa methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/19/2022 01:09'!esCombinada "Mensaje que devuelve true si la empresa es combinada y false si no lo es una empresa combinada tiene una coleccion de productos que ofrece y en este caso su colProductos no esta vacia, caso contrario con las que no son combinadas"^colProductos  isNotEmpty .! !!Empresa methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2023 13:32'!getAtributoClave ^ nombre ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Empresa class	instanceVariableNames: ''!!Empresa class methodsFor: 'initialization' stamp: 'Ulises 2/21/2022 12:47'!getMaximo	^MAXIMO ! !!Empresa class methodsFor: 'initialization' stamp: 'Ulises 2/21/2022 12:47'!setMaximo: unValor	MAXIMO := unValor ! !!Empresa class methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/15/2022 03:30'!crear: unNombre conRubro: unRubro conEmail: unEmail conTel: unTel |unaEmpresa|unaEmpresa:= self new.unaEmpresa inicializar: unNombre conRubro: unRubro conEmail: unEmail conTel: unTel.^unaEmpresa.! !!Empresa class methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/15/2022 03:30'!crear: unNombre conRubro: unRubro conEmail: unEmail conTel: unTel conServicio: unServ|unaEmpresa|unaEmpresa:= self new.unaEmpresa inicializar: unNombre conRubro: unRubro conEmail: unEmail conTel: unTel conServ: unServ.^unaEmpresa.! !!Empresa class methodsFor: 'as yet unclassified' stamp: 'Ulises 1/27/2023 20:08'!crear: unNombre		              conRubro: unRubro		              conEmail: unEmail		              conTel: unTel		              conServ: unServ		              conProductos: unaColProductos		              conRango: unRango		              conPuntualidad: unaPuntualidad	| unaEmpresa |	unaEmpresa := self new.	unaEmpresa		inicializar: unNombre		              conRubro: unRubro		              conEmail: unEmail		              conTel: unTel		              conServ: unServ		              conProductos: unaColProductos		              conRango: unRango		              conPuntualidad: unaPuntualidad.	^ unaEmpresa! !Empresa subclass: #EmpresaSolicitante	instanceVariableNames: 'colSolicitud colSolicitudesResueltas'	classVariableNames: ''	package: 'TPFinalObligatorio'!!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 17:37'!tieneSolicitud: unaSolicitud^ colSolicitud anySatisfy: [ :cadaUnaSolicitud | cadaUnaSolicitud esIgual: unaSolicitud  ]! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/22/2022 15:37'!getSolicitudesPendientes	"Metodo que devuelve una coleccion con las solicitudes que no estan vencidas"	|solPendientes|	solPendientes := colSolicitud reject: [ :unaSolicitud | unaSolicitud estaVencida ].	^solPendientes ! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/23/2022 16:09'!eliminarSolicitudesVencidas	"Elimina las solicitudes vencidas de la coleccion de solitudes y las retorna"	| solicitudesVencidas |	solicitudesVencidas := colSolicitud select: [ :unaSolicitud | 		                       unaSolicitud estaVencida ].	colSolicitud removeAll: solicitudesVencidas.	^ solicitudesVencidas! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/23/2022 03:29'!getSolicitudesVencidas^ colSolicitud select: [ :unaSol | unaSol estaVencida  ]! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 1/29/2023 22:27'!inicializar: unNombre conRubro: unRubro conEmail: unEmail conTel: unTel	super		inicializar: unNombre		conRubro: unRubro		conEmail: unEmail		conTel: unTel.	colSolicitud := OrderedCollection new.	colSolicitudesResueltas := OrderedCollection new! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 1/29/2023 22:05'!registrarSolicitudTrabajo:  unaFecha conFechaVen: unaFechaVen conMonto: unMonto conCargo: unCargo conDescripcion: unaDescripcioncolSolicitud add: (DeTrabajo crear: unaFecha conFechaVen: unaFechaVen conMonto: unMonto conCargo: unCargo conDescripcion: unaDescripcion)! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/23/2022 17:55'!getSolicitudesPendientesRegistradas: unaFecha	^ colSolicitud select: [ :unaSolicitud | 		  (unaSolicitud estaRegistradaFecha: unaFecha)  and: (unaSolicitud estaVencida) not  ]! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/20/2022 02:26'!revalidarSolicitud: unaSolicitud conCantDias: unaCantDias"Mensaje que revalida una solicitud vencida por la cantidad de dias estipulada por una empresa"unaSolicitud extenderFechaVencimiento: unaCantDias.! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/4/2023 21:12'!getTipo	^ ' ' join: (self className splitCamelCase) ! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/23/2022 03:10'!marcarResuelta: unaSolicitud	colSolicitud		removeAllSuchThat:  [ :cadaUnaSolicitud | 		cadaUnaSolicitud esIgual: unaSolicitud ].			colSolicitudesResueltas add: (unaSolicitud setEstado: $R)! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/22/2022 02:29'!inicializar: unNombre conRubro: unRubro conEmail: unEmail conTel: unTel conServ: unServ conSolicitud: unaColSol	self		inicializar: unNombre		conRubro: unRubro		conEmail: unEmail		conTel: unTel		conServ: unServ.	colSolicitud := unaColSol.	colSolicitudesResueltas := OrderedCollection new.! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/24/2022 03:51'!getCantidadSolResueltas^colSolicitudesResueltas size! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/21/2022 23:02'!registrarSolicitudServPuntual: diaActual conFechaVencimiento: unaFechaV conMonto: unMonto conCaracteristicas: unaCaracteristicas conServicio: unServicio colSolicitud add:( DeServicio crearPuntual: diaActual  conFechaVen: unaFechaV  conMonto: unMonto conCaracteristicas: unaCaracteristicas   conServicio: unServicio)! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 1/29/2023 19:38'!registrarSolServProPuntual: unaFecha conFechaVen: unaFechaVen conMonto: unMonto conCaracteristicas: unaCarac conServicio: unServicio conProducto: unProducto	colSolicitud add: (YProducto			 crearPuntual: unaFecha			 conFechaVen: unaFechaVen			 conMonto: unMonto			 conCaracteristicas: unaCarac			 conServicio: unServicio			 conProducto: unProducto)! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/6/2023 20:32'!getColSolicitudes	"Metodo que retorna la coleccion de solicitudes de la empresa"	^colSolicitud ! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/22/2022 00:31'!marcarSolicitudesVencidas: diaActual	colSolicitud		do: [ :unaSolicitud | 			(unaSolicitud verificarVencimiento: diaActual) ifTrue: [ 				unaSolicitud setEstado: $V ] ]		! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/22/2023 02:11'!getColSolicitudesResueltas	^ colSolicitudesResueltas ! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/22/2022 00:01'!registrarSolicitudServUniforme: diaActual conFechaVencimiento: unaFechaV conMonto: unMonto conCaracteristicas: unaCaracteristicas conDuracion: unaDuracion conFormaPago: unaForma conServicio: unServicio colSolicitud add:( DeServicio crearUniforme:  diaActual conFechaVen: unaFechaV   conMonto: unMonto conCaracteristicas: unaCaracteristicas  conDuracion: unaDuracion  conFormaPago: unaForma  conServicio: unServicio  )! !!EmpresaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 1/29/2023 19:33'!registrarSolServProUniforme: unaFecha conFechaVen: unaFechaVen conMonto: unMonto conCaracteristicas: unaCarac conDuracion: unaDuracion conFormaPago: unaForma conServicio: unServicio conProducto: unProductocolSolicitud add: (YProducto crearUniforme: unaFecha  conFechaVen: unaFechaVen  conMonto: unMonto conCaracteristicas: unaCarac   conDuracion: unaDuracion   conFormaPago: unaForma  conServicio:  unServicio conProducto: unProducto  )! !Postulante subclass: #Persona	instanceVariableNames: 'dni apellido colAptitud'	classVariableNames: 'MAXIMO_INDIVIDUAL'	package: 'TPFinalObligatorio'!!Persona methodsFor: 'as yet unclassified' stamp: 'Ulises 2/20/2022 02:34'!esAptoTrabajo: unCargo^ colAptitud anySatisfy: [ :unaAptitud | unaAptitud = unCargo  ]! !!Persona methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2023 13:31'!getAtributoClave^ dni! !!Persona methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 13:31'!noSuperaMaximo: unMonto^ unMonto <= MAXIMO_INDIVIDUAL ! !!Persona methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2023 22:45'!inicializar: unNombre conEmail: unEmail conTel: unTel conDni: unDni conApellido: unApe conAptitud: unaColApt	self inicializar: unNombre conEmail: unEmail conTel: unTel.	dni:= unDni.	apellido := unApe.	colAptitud := unaColApt! !!Persona methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/19/2022 01:19'!esAptoServicio: unServicio conPuntualidad: unaPuntualidad^colAptitud anySatisfy: [ :unaAptitud | unaAptitud = unServicio ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Persona class	instanceVariableNames: ''!!Persona class methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2023 22:46'!crear: unNombre conEmail: unEmail conTel: unTel conDni: unDni conApellido: unApe conAptitud: unaColApt	| unaPersona |	unaPersona := self new.	^ unaPersona		  inicializar: unNombre		  conEmail: unEmail		  conTel: unTel		conDni: unDni		  conApellido: unApe		  conAptitud: unaColApt! !!Persona class methodsFor: 'initialization' stamp: 'Ulises 2/21/2022 13:32'!setMaximoIndividual: unValorMAXIMO_INDIVIDUAL := unValor ! !!Persona class methodsFor: 'initialization' stamp: 'Ulises 2/21/2022 13:32'!getMaximoIndividual^	MAXIMO_INDIVIDUAL ! !Object subclass: #Propuesta	instanceVariableNames: 'solicitudPropuesta postulantePropuesta'	classVariableNames: ''	package: 'TPFinalObligatorio'!!Propuesta methodsFor: 'accessing' stamp: 'Ulises 2/24/2023 00:55'!esIgual: unaSolicitud conPostulante: unPostulante	^ (solicitudPropuesta esIgual: unaSolicitud) and: [ 		  postulantePropuesta esIgual: unPostulante getAtributoClave  ]! !!Propuesta methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 13:45'!inicializarConSolicitud: unaSolicitud conPostulante: unPostulante solicitudPropuesta := unaSolicitud .postulantePropuesta := unPostulante ! !!Propuesta methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 17:00'!getSolicitud^ solicitudPropuesta ! !!Propuesta methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/23/2022 02:42'!tieneSolicitud: unaSolicitud	"Mensaje que retorna un boolean dependiendo si la propuesta contiene o no la solicitud mandada por parametro"	^ solicitudPropuesta esIgual: unaSolicitud! !!Propuesta methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/27/2023 22:44'!esFraude: unaEmpresaSolicitante	| respuesta |	respuesta := postulantePropuesta esEmpresa ifTrue: [ 		             postulantePropuesta getAtributoClave		             = unaEmpresaSolicitante getAtributoClave ]	ifFalse: [ false].	^ respuesta! !!Propuesta methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 17:03'!getPostulante ^postulantePropuesta ! !!Propuesta methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 17:04'!esIgual: unaPropuesta	^ (solicitudPropuesta esIgual:  unaPropuesta getSolicitud)	  & (postulantePropuesta esIgual: unaPropuesta getPostulante)! !!Propuesta methodsFor: 'printing' stamp: 'Torgeck 7/23/2022 00:21'!toString	^ 'Propuesta con solicitud: ' , solicitudPropuesta toString	  , ' y con postulante: ' , postulantePropuesta toString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Propuesta class	instanceVariableNames: ''!!Propuesta class methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 13:47'!crearConSolicitud: unaSolicitud conPostulante: unPostulante	| unaPropuesta |	unaPropuesta := self		                new.		unaPropuesta 		             inicializarConSolicitud: unaSolicitud		                conPostulante: unPostulante.	^ unaPropuesta! !Object subclass: #Solicitud	instanceVariableNames: 'idSolicitud fechaRegistro fechaVencimiento monto estado'	classVariableNames: 'ID_ACTUAL'	package: 'TPFinalObligatorio'!!Solicitud methodsFor: 'printing' stamp: 'Ulises 2/15/2023 13:32'!toString	^ 'ID: ' , idSolicitud asString , ' '! !!Solicitud methodsFor: 'accessing' stamp: 'Ulises 2/16/2023 15:17'!extenderFechaVencimiento: unaCantDias"Mensaje que extiende la fecha de vencimiento de la solicitud receptora del mismo por una cantidad de dias pasada como argumento"	(unaCantDias isNil and: unaCantDias <= 1) ifTrue: [ ^ self ].	fechaVencimiento := fechaVencimiento addDays: unaCantDias.	self setEstado: $P! !!Solicitud methodsFor: 'accessing' stamp: 'Torgeck 7/22/2022 22:53'!obtenerPostulantesValidos: unaColPostulantes 	^ self subclassResponsibility! !!Solicitud methodsFor: 'initialization' stamp: 'Ulises 2/21/2022 19:06'!setEstado: unaLetraestado := unaLetra ! !!Solicitud methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/23/2022 04:08'!estaVencida	^ estado sameAs:  $V! !!Solicitud methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/23/2022 16:04'!verificarVencimiento: diaActual	"Verifica si la solicitud esta vencida al dia de 'hoy' y retorna un boolean"	^ (fechaVencimiento  subtractDate: diaActual ) <= 0! !!Solicitud methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/23/2022 02:29'!inicializar: unaFecha conFechaVen: unaFechaVen conEstado: unEstado conMonto: unMonto	estado := unEstado.	fechaRegistro := unaFecha.	fechaVencimiento := unaFechaVen.	monto := unMonto.	idSolicitud := self generarId ! !!Solicitud methodsFor: 'as yet unclassified' stamp: 'Ulises 2/6/2023 23:23'!getMonto	^ monto! !!Solicitud methodsFor: 'as yet unclassified' stamp: 'Ulises 2/24/2022 03:44'!estaRegistradaFecha: unaFecha^ fechaRegistro equals: unaFecha ! !!Solicitud methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 17:06'!getId ^idSolicitud ! !!Solicitud methodsFor: 'as yet unclassified' stamp: 'Ulises 2/6/2023 23:27'!getFechaVencimiento	"retorna la fecha registrada"	^ fechaVencimiento ! !!Solicitud methodsFor: 'as yet unclassified' stamp: 'Ulises 2/20/2022 01:43'!verificarPostulanteValido: unPostulante"Metodo polimorfico que verifica que un postulante sea valido para la solicitud a la que se le manda el msj"self subclassResponsibility ! !!Solicitud methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2022 17:05'!esIgual: unaSolicitud^idSolicitud = unaSolicitud getId.! !!Solicitud methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/20/2022 04:42'!generarId	| idGenerado |	idGenerado := self class getID_ACTUAL.	self class setID_ACTUAL: idGenerado + 1.	^ idGenerado! !!Solicitud methodsFor: 'as yet unclassified' stamp: 'Ulises 2/6/2023 23:22'!getEstado^estado! !!Solicitud methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/23/2022 02:29'!inicializar: unaFecha conFechaVen: unaFechaVen conMonto: unMonto	estado := $P.	fechaRegistro := unaFecha.	fechaVencimiento := unaFechaVen.	monto := unMonto.	idSolicitud := self generarId .! !!Solicitud methodsFor: 'as yet unclassified' stamp: 'Ulises 2/19/2022 18:08'!getFechaRegistro"retorna la fecha registrada"^fechaRegistro ! !!Solicitud methodsFor: 'as yet unclassified' stamp: 'Ulises 2/6/2023 23:33'!getTipo	"retorna la fecha registrada"	^ 'Solicitud'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Solicitud class	instanceVariableNames: ''!!Solicitud class methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/20/2022 04:42'!getID_ACTUAL^ID_ACTUAL .! !!Solicitud class methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/20/2022 04:42'!setID_ACTUAL: unID	^ ID_ACTUAL := unID.! !Solicitud subclass: #DeServicio	instanceVariableNames: 'servicio caracteristicas duracion formaPago'	classVariableNames: ''	package: 'TPFinalObligatorio'!!DeServicio methodsFor: 'printing' stamp: 'Ulises 2/15/2023 13:31'!toString	^ super toString , 'Servicio solicitado: ' , servicio	  , ' Forma de pago: ' , ' Caracteristicas: ' , caracteristicas! !!DeServicio methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/18/2022 15:29'!esPuntual "Mensaje que retorna si un servicio es puntual o uniforme"^duracion = 0.! !!DeServicio methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/20/2022 05:36'!inicializarPuntual: unaFecha conFechaVen: unaFechaVen conMonto: unMonto conCaracteristicas: unaCarac conServicio: unServicio	self		inicializar: unaFecha		conFechaVen: unaFechaVen		conMonto: unMonto.	caracteristicas := unaCarac.	duracion := 0.	formaPago := nil.	servicio := unServicio! !!DeServicio methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/22/2022 23:05'!obtenerPostulantesValidos: unaColPostulantes	"Metodo que genera y retorna una coleccion con postulantes aptos para dicha solicitud"	| colValidos puntualidad |	"Obtengo si la solicitud es puntual o no"	puntualidad := self esPuntual.	"Ahora obtengo los postulantes aptos para la solicitud"	colValidos := unaColPostulantes select: [ :unPostulante | 		              self verificarPostulanteValido: unPostulante conPuntualidad: puntualidad ].	^ colValidos! !!DeServicio methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/20/2022 05:36'!inicializarUniforme: unaFecha conFechaVen: unaFechaVen conMonto: unMonto conCaracteristicas: unaCarac conDuracion: unaDuracion conFormaPago: unaForma conServicio: unServicio	self		inicializar: unaFecha		conFechaVen: unaFechaVen		conMonto: unMonto.	caracteristicas := unaCarac.	duracion := unaDuracion.	formaPago := unaForma.	servicio := unServicio! !!DeServicio methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/22/2022 23:08'!verificarPostulanteValido: unPostulante conPuntualidad: unaPuntualidad	"Mensaje que verifica si un postulante cumple con las condiciones de la solicitud"	| respuesta |	respuesta := false.	(unPostulante esAptoServicio: servicio conPuntualidad: unaPuntualidad) ifTrue: [ 		respuesta := unPostulante noSuperaMaximo: monto ].	^ respuesta! !!DeServicio methodsFor: 'as yet unclassified' stamp: 'Ulises 2/6/2023 23:32'!getTipo	^ super getTipo , ' de servicio'! !!DeServicio methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/20/2022 05:00'!inicializar: unaFecha  conFechaVen: unaFechaVen  conEstado: unEstado  conMonto: unMonto conCaracteristicas: unaCarac conDuracion: unaDuracion conFormaPago: unaForma conServicio: unServicioself inicializar: unaFecha  conFechaVen: unaFechaVen   conEstado: unEstado   conMonto: unMonto .caracteristicas := unaCarac .duracion := unaDuracion.formaPago := unaForma .servicio := unServicio .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DeServicio class	instanceVariableNames: ''!!DeServicio class methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/21/2022 21:20'!crearUniforme: unaFecha conFechaVen: unaFechaVen conMonto: unMonto conCaracteristicas: unaCarac conDuracion: unaDuracion conFormaPago: unaForma conServicio: unServicio"Mensaje que crea una instancia de la clase DeServicio uniforme"|unaSolicitud|unaSolicitud := self new.^ unaSolicitud inicializarUniforme: unaFecha   conFechaVen: unaFechaVen   conMonto: unMonto conCaracteristicas: unaCarac conDuracion: unaDuracion  conFormaPago: unaForma  conServicio: unServicio.  ! !!DeServicio class methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/21/2022 21:16'!crearPuntual: unaFecha conFechaVen: unaFechaVen conMonto: unMonto conCaracteristicas: unaCarac conServicio: unServicio"Mensaje que crea una instancia de la clase DeServicio puntual"|unaSolicitud|unaSolicitud := self new.^ unaSolicitud inicializarPuntual: unaFecha conFechaVen: unaFechaVen  conMonto: unMonto conCaracteristicas: unaCarac  conServicio: unServicio! !Solicitud subclass: #DeTrabajo	instanceVariableNames: 'descripcion cargo'	classVariableNames: ''	package: 'TPFinalObligatorio'!!DeTrabajo methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/20/2022 05:35'!inicializar: unaFecha conFechaVen: unaFechaVen  conMonto: unMonto conCargo: unCargo conDescripcion: unaDescripcion	self		inicializar: unaFecha		conFechaVen: unaFechaVen		conMonto: unMonto.	cargo := unCargo.	descripcion := unaDescripcion! !!DeTrabajo methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/18/2022 15:37'!obtenerPostulantesValidos: unaColPostulantes"Mensaje que obtiene y retorna los postulantes aptos para la solicitud de trabajo"^unaColPostulantes select: [ :unPostulante | unPostulante esAptoTrabajo: cargo ].! !!DeTrabajo methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/20/2022 05:34'!inicializar: unaFecha conFechaVen: unaFechaVen  conEstado: unEstado conMonto: unMonto conCargo: unCargo conDescripcion: unaDescripcionself inicializar: unaFecha  conFechaVen: unaFechaVen  conEstado: unEstado  conMonto: unMonto .cargo:= unCargo .descripcion := unaDescripcion .! !!DeTrabajo methodsFor: 'as yet unclassified' stamp: 'Ulises 2/6/2023 23:32'!getTipo	^ super getTipo , ' de trabajo'! !!DeTrabajo methodsFor: 'as yet unclassified' stamp: 'Ulises 2/20/2022 02:30'!verificarPostulanteValido: unPostulante	"Mensaje que responde si el postulante pasado por parametro es apto para el trabajo"^ unPostulante esAptoTrabajo: cargo.! !!DeTrabajo methodsFor: 'printing' stamp: 'Ulises 2/15/2023 13:32'!toString	^ super toString , 'Cargo: ' , cargo , ' Descripcion: '	  , descripcion! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DeTrabajo class	instanceVariableNames: ''!!DeTrabajo class methodsFor: 'as yet unclassified' stamp: 'Ulises 1/29/2023 22:04'!crear: unaFecha conFechaVen: unaFechaVen conMonto: unMonto conCargo: unCargo conDescripcion: unaDescripcion|unaSolTrabajo|unaSolTrabajo := self new.^ unaSolTrabajo inicializar: unaFecha conFechaVen: unaFechaVen conMonto: unMonto conCargo: unCargo conDescripcion: unaDescripcion! !RubTextFieldMorph subclass: #TextFieldMorph	instanceVariableNames: ''	classVariableNames: ''	package: 'TPFinalObligatorio'!!TextFieldMorph methodsFor: 'text managing' stamp: 'Torgeck 2/28/2023 12:13'!getString	"Retorna el texto como string que se encuentra en el textField"	^ self textArea text asString! !!TextFieldMorph methodsFor: 'text managing' stamp: 'Torgeck 2/28/2023 12:14'!getStringUppercase"Retorna el texto como string en mayusculas que se encuentra en el textField"	^ self textArea text asString asUppercase! !BorderedMorph subclass: #Ventana	instanceVariableNames: 'barra alto ancho'	classVariableNames: ''	package: 'TPFinalObligatorio'!!Ventana methodsFor: 'as yet unclassified' stamp: 'Ulises 2/27/2023 16:02'!crearStringMorph: unString	"Mensaje que retorna un stringMorph"	| unStringMorph |	^unStringMorph := StringMorph		                 contents: unString		                 font: nil		                 emphasis: TextEmphasis bold! !!Ventana methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 01:00'!cambiarColumnasSolicitudes: unaTabla	"Mensaje que cambia las columnas del morphLista para mostrar solicitudes"	unaTabla  columns: { 			(FTColumn id: 'Descripcion').			((FTColumn id: 'Estado') width: 50).			((FTColumn id: 'Monto') width: 60).			((FTColumn id: 'Tipo') width: 120).			((FTColumn id: 'Fecha registro') width: 120).			((FTColumn id: 'Fecha vencimiento') width: 120) }! !!Ventana methodsFor: 'as yet unclassified' stamp: 'Ulises 2/27/2023 16:01'!inicializarConAlto: unAlto conAncho: unAncho conTitulo: unTitulo	"Metodo que inicializa una ventana con un alto, ancho y un titulo"	self		initialize;		bounds: (self position extent: unAncho @ unAlto);		layoutPolicy: TableLayout new.	self		listDirection: #bottomToTop;		listCentering: #topLeft;		wrapCentering: #topLeft;		layoutInset: 0.	"Se crea e inicializa la barra"	barra := BarraVentana new.	barra inicializarConTitulo: unTitulo.	"Se agrega la barra a la ventana y se procede a abrir la ventana centrada en el world"	self addMorph: barra.	self openCenteredInWorld! !!Ventana methodsFor: 'as yet unclassified' stamp: 'Ulises 2/16/2023 15:36'!redimensionarBotones: unaColBotones	"Metodo que redimensiona el ancho de todos los botones por el ancho mas grande de la coleccion"	| botonMax anchoMax alturaMax |	botonMax := unaColBotones detectMax: [ :unBoton | unBoton width ].	anchoMax := botonMax width.	alturaMax := botonMax height.	^ unaColBotones collect: [ :unBoton | 		  unBoton extent:			  anchoMax  + 10 @ alturaMax   + 5 ]! !!Ventana methodsFor: 'as yet unclassified' stamp: 'Ulises 2/24/2023 02:16'!inicializarMorphContenedor	"Mensaje que crea un morph contenedor de otros morphs con layoutPolicy"	| unMorph |	unMorph := Morph new.	^ unMorph		  initialize;		  color: Color transparent ;		  layoutPolicy: TableLayout new;		  layoutInset: 10;		  listDirection: #rightToLeft;		  cellInset: 10;		  hResizing: #spaceFill;		  vResizing: #shrinkWrap! !!Ventana methodsFor: 'as yet unclassified' stamp: 'Ulises 2/27/2023 15:48'!inicializarMorphContenedor: unaDireccion	"Mensaje que crea un morph contenedor de otros morphs con layoutPolicy"	| unMorph |	unMorph := Morph new.	^ unMorph		  initialize;		  color: (Color fromHexString: 'D0CECF') twiceDarker;		  layoutPolicy: TableLayout new;		  layoutInset: 10;		  listDirection: unaDireccion;		  cellInset: 10;		  hResizing: #spaceFill;		  vResizing: #shrinkWrap! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Ventana class	instanceVariableNames: ''!!Ventana class methodsFor: 'as yet unclassified' stamp: 'Ulises 2/9/2023 15:12'!crear: unGestor	| unMorph |	unMorph := self new.	^ unMorph inicializar: unGestor! !Ventana subclass: #Formulario	instanceVariableNames: 'botonRegistrar botonCancelar'	classVariableNames: ''	package: 'TPFinalObligatorio'!!Formulario methodsFor: 'as yet unclassified' stamp: 'Ulises 1/27/2023 17:44'!hayTextFieldsVacios"Mensaje que responde si el receptor del mensaje contiene textFields vacios"self subclassResponsibility ! !!Formulario methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/27/2023 21:30'!registrar: unGestor	^self subclassResponsibility ! !!Formulario methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/27/2023 21:22'!accionBotonRegistrar: unGestor	"Checkeo si hay textFields sin completar por el usuario"	self hayTextFieldsVacios		ifTrue: [ 			UIManager default				alert: 'Hay uno o mas campos vacios'				title: 'Campos vacios' ]		ifFalse: [ 			(self registrar: unGestor)				ifTrue: [ unGestor changed.					self delete ]				ifFalse: [ self alertarExistencia ] ]! !!Formulario methodsFor: 'as yet unclassified' stamp: 'Ulises 2/25/2023 01:35'!inicializar^self subclassResponsibility ! !!Formulario methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2023 14:30'!alertarExistenciaself subclassResponsibility ! !!Formulario methodsFor: 'as yet unclassified' stamp: 'Ulises 2/25/2023 01:35'!inicializarConAlto: unAlto conAncho: unAncho conTitulo: unTitulo	super		inicializarConAlto: unAlto		conAncho: unAncho		conTitulo: unTitulo.	self inicializar! !!Formulario methodsFor: 'as yet unclassified' stamp: 'Ulises 2/24/2023 22:38'!crearBotonesFormulario	"Mensaje que crea y retorna los botones propios del formulario al mismo"	| contenedor colBot |	"Inicializo el morph contenedor de los botones"	contenedor := self inicializarMorphContenedor.	"Inicializo los botones de registrar y cancelar"	colBot:= self redimensionarBotones: { 			(botonRegistrar := Boton newWithLabel: 'Registrar').			(botonCancelar := Boton newWithLabel: 'Cancelar') }.	"Los agrego al morph contenedor"	contenedor addAllMorphs: colBot.	"Agrego el contenedor a mi"	^ contenedor! !!Formulario methodsFor: 'as yet unclassified' stamp: 'Ulises 1/27/2023 21:11'!obtenerColeccion: unTextField	"Mensaje que separa un string dividido por / y retorna una coleccion"	| coleccion |	unTextField		ifNil: [ coleccion := OrderedCollection new ]		ifNotNil: [ 			coleccion := ((unTextField getString) splitOn: '/') collect: [ :unElemento | 				             unElemento asUppercase ] ].	^ coleccion! !!Formulario methodsFor: 'as yet unclassified' stamp: 'Ulises 2/27/2023 16:13'!crearCheckBoxMorph: unMorph conLabel: unaLabel	"Mensaje que crea un morph checkBox con layoutProperties y lo retorna; el Morph pasado por parametro tiene que estar ya creado"	| contenedor morphString |	"Inicializo el morph contenedor"	contenedor := self inicializarMorphContenedor: #leftToRight.	"Creo e inicializo el string que va a acompaniar al checkBoxMorph"	morphString := self crearStringMorph: unaLabel.	contenedor addAllMorphs: { 			morphString.			unMorph }.	^ contenedor! !!Formulario methodsFor: 'as yet unclassified' stamp: 'Ulises 2/27/2023 16:09'!crearTextFieldMorph: unMorph conLabel: unaLabel conGhostText: unGhostText	"Mensaje que crea un morph contenedor con layoutProperties y lo retorna; el Morph pasado por parametro tiene que estar ya creado"	| contenedor morphString |	"Inicializo el morph contenedor"	contenedor := self inicializarMorphContenedor: #rightToLeft.	"Creo e inicializo los morphs que van a ir dentro del morphContenedor"	morphString := self crearStringMorph: unaLabel.	unMorph		initialize;		hResizing: #spaceFill;		ghostText: unGhostText.	contenedor addAllMorphs: { 			unMorph.			morphString }.	^ contenedor! !Formulario subclass: #FormularioPostulante	instanceVariableNames: 'nombre email telefono'	classVariableNames: ''	package: 'TPFinalObligatorio'!!FormularioPostulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/24/2023 23:32'!crearTextFields	"Mensaje que crea los texfields de las clase postulante y retorna una coleccion de morphs"	^  OrderedCollection newFrom:  { 		  (self			   crearTextFieldMorph: nombre			   conLabel: 'Nombre: '			   conGhostText: 'Manolo').		  (self			   crearTextFieldMorph: telefono			   conLabel: 'Telefono: '			   conGhostText: '2994343456').		  (self			   crearTextFieldMorph: email			   conLabel: 'Email: '			   conGhostText: 'email@gmail.com') } ! !!FormularioPostulante methodsFor: 'as yet unclassified' stamp: 'Ulises 1/27/2023 18:02'!hayTextFieldsVacios"Mensaje que indica si el receptor tiene alguno de sus textField vacios"^ nombre getString = '' or: ( email getString = '' or: telefono getString = '')! !!FormularioPostulante methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 12:15'!inicializar	"Metodo que inicializa el formulario para un postulante"	"Creo los textFields"	nombre := TextFieldMorph new.	email := TextFieldMorph new.	telefono := TextFieldMorph new! !FormularioPostulante subclass: #FormularioPersona	instanceVariableNames: 'dni apellido colAptitud'	classVariableNames: ''	package: 'TPFinalObligatorio'!!FormularioPersona methodsFor: 'accessing' stamp: 'Ulises 2/21/2023 22:43'!hayTextFieldsVacios	"Mensaje que indica a traves de un boolean si el receptor del mensaje posee textFields vacios, en caso de no estar inicializados se ignoran"	^ super hayTextFieldsVacios or: (apellido getString = '' or:			   (colAptitud getString = '' or: dni getString = ''))! !!FormularioPersona methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 12:15'!inicializar: unGestor	"Mensaje que inicializa la clase FormularioPersona"	| contenedor |	self		inicializarConAlto: 405		conAncho: 400		conTitulo: 'Formulario Persona'.	self inicializar.	"Agrego los submorphs propios de la clase"	contenedor := self inicializarMorphContenedor: #topToBottom.	contenedor vResizing: #spaceFill.	"Le aniado los submorphs a loa contenedores correspondientes "	contenedor addAllMorphs: self crearTextFields.	self addMorph: contenedor.	"Agrego funcionalidad a los botones"	botonCancelar mouseAction: [ self delete ].	botonRegistrar mouseAction: [ self accionBotonRegistrar: unGestor ]! !!FormularioPersona methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2023 14:32'!alertarExistencia UIManager default				alert: 'Ya se existe una persona con el dni ingresado'				title: 'Atencion'  ! !!FormularioPersona methodsFor: 'as yet unclassified' stamp: 'Ulises 2/24/2023 23:38'!crearTextFields	"Mensaje que retorna una coleccion de textfields"	| colMorphs |	colMorphs := super crearTextFields.	colMorphs		  add: (self				   crearTextFieldMorph: apellido				   conLabel: 'Apellido: '				   conGhostText: 'Soria')		  afterIndex: 1 ;		  addAllLast: { 				  (self					   crearTextFieldMorph: dni					   conLabel: 'DNI:'					   conGhostText: '11111111').				  (self					   crearTextFieldMorph: colAptitud					   conLabel: 'Aptitud/es: '					   conGhostText: 'pintor/electricista/etc').				  self crearBotonesFormulario }.				^colMorphs ! !!FormularioPersona methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/27/2023 21:56'!registrar: unGestor	"Mensaje que registra al receptor del mensaje en el gestor pasado por parametro"	| respuesta |	(respuesta := unGestor		              registrarPersona: nombre getStringUppercase		              conEmail: email getStringUppercase		              conTel: telefono getText asNumber		              conDni: dni getText asNumber		              conApellido: apellido getStringUppercase		              conAptitud: (self obtenerColeccion: colAptitud)) 		.	^ respuesta! !!FormularioPersona methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 12:16'!inicializar	super inicializar.	dni := TextFieldMorph new.	apellido := TextFieldMorph new.	colAptitud := TextFieldMorph new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FormularioPersona class	instanceVariableNames: ''!!FormularioPersona class methodsFor: 'as yet unclassified' stamp: 'Ulises 2/3/2023 21:29'!crear: unGestor	|unFormulario|		unFormulario := self new.	^unFormulario inicializar: unGestor! !FormularioPostulante subclass: #FormularioSolicitante	instanceVariableNames: 'rubro'	classVariableNames: ''	package: 'TPFinalObligatorio'!!FormularioSolicitante methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/27/2023 20:14'!inicializar: unGestor	"Mensaje que inicializa el formulario para registrar una empresa solicitante"	| contenedor |	self		inicializarConAlto: 305		conAncho: 400		conTitulo: 'Formulario Empresa solicitante'.	"Inicializo los atributos propios de la clase"	contenedor := self inicializarMorphContenedor: #topToBottom.	contenedor vResizing: #spaceFill.	contenedor addAllMorphs: self crearTextFields.	contenedor addMorphBack: self crearBotonesFormulario.	self addMorph: contenedor.	"Agrego funcionalidad a los botones"	botonCancelar mouseAction: [ self delete ].	botonRegistrar mouseAction: [ self accionBotonRegistrar: unGestor ]! !!FormularioSolicitante methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/27/2023 19:46'!crearTextFields	"Mensaje que retorna una coleccion de textfields"	|colMorphs| colMorphs := super crearTextFields .colMorphs addLast: (	self		crearTextFieldMorph: rubro		conLabel: 'Rubro: '		conGhostText: 'Automotor').^colMorphs ! !!FormularioSolicitante methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/27/2023 19:54'!alertarExistencia	UIManager default		alert: 'Ya se existe una empresa con el nombre ingresado'		title: 'Atencion'! !!FormularioSolicitante methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 12:17'!inicializar	super inicializar.	rubro := TextFieldMorph  new! !!FormularioSolicitante methodsFor: 'accessing' stamp: 'Torgeck 2/27/2023 20:44'!hayTextFieldsVacios	"Mensaje que indica a traves de un boolean si el receptor del mensaje posee textFields vacios"	^ super hayTextFieldsVacios or: rubro getString = ''! !!FormularioSolicitante methodsFor: 'accessing' stamp: 'Torgeck 2/27/2023 21:59'!registrar: unGestor	| respuesta |	"Mensaje que registra un postulante al gestor empleos"	respuesta := unGestor		             registrarEmpresaSolicitante: nombre getStringUppercase		             conRubro: rubro getStringUppercase		             conEmail: email getStringUppercase		             conTel: telefono getText asNumber.	^ respuesta! !FormularioSolicitante subclass: #FormularioEmpresa	instanceVariableNames: 'rango servicioProvisto esPuntual colProductos esSolicitante'	classVariableNames: ''	package: 'TPFinalObligatorio'!!FormularioEmpresa methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2023 14:32'!alertarExistencia	UIManager default		alert: 'Ya se existe una empresa con el nombre ingresado'		title: 'Atencion'! !!FormularioEmpresa methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/27/2023 21:06'!crearTextFields	"Mensaje que retorna una coleccion de textfields"	| colMorphs |	colMorphs := super crearTextFields.	colMorphs addAllLast: { 			(self				 crearTextFieldMorph: rango				 conLabel: 'Rango: '				 conGhostText: '2').			(self				 crearTextFieldMorph: servicioProvisto				 conLabel: 'Servicio provisto: '				 conGhostText: 'Reparacion').			(self				 crearCheckBoxMorph: esPuntual				 conLabel: '¿El servicio que brinda es puntual?').			self crearBotonesFormulario }.	^ colMorphs! !!FormularioEmpresa methodsFor: 'as yet unclassified' stamp: 'Ulises 2/25/2023 00:32'!crearTextFieldsCombinada	"Mensaje que retorna una coleccion de textfields"	| colMorphs |	colMorphs := self crearTextFields.	colMorphs		add: (self				 crearTextFieldMorph: colProductos				 conLabel: 'Producto/s ofrecidos: '				 conGhostText: 'Pintura/Detergente/etc')		afterIndex: 6.	^ colMorphs! !!FormularioEmpresa methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 12:17'!inicializar	super inicializar.	esPuntual := CheckboxButtonMorph checkBox.	rubro := TextFieldMorph new.	rango := TextFieldMorph new.	servicioProvisto := TextFieldMorph new! !!FormularioEmpresa methodsFor: 'accessing' stamp: 'Ulises 1/27/2023 18:49'!hayTextFieldsVacios	"Mensaje que indica a traves de un boolean si el receptor del mensaje posee textFields vacios, en caso de no estar inicializados se ignoran"	| respuesta aux |	aux := OrderedCollection withAll: { 			       colProductos.			       rubro.			       servicioProvisto.			       rango }.	respuesta := aux select: [ :unTextField | 		             unTextField			             ifNotNil: [ 				             unTextField getString = '' ]			             ifNil: false ].	^ super hayTextFieldsVacios or: respuesta isNotEmpty! !!FormularioEmpresa methodsFor: 'accessing' stamp: 'Torgeck 2/27/2023 21:59'!registrar: unGestor	"Mensaje que registra un postulante al gestor empleos"	| respuesta |	respuesta := unGestor		             registrarEmpresaPostulante: nombre getStringUppercase		             conRubro: rubro getStringUppercase		             conEmail: email getStringUppercase		             conTel: telefono getText asNumber		             conServ: servicioProvisto getStringUppercase		             conProductos: (self obtenerColeccion: colProductos)		             conRango: rango getText asNumber		             conPuntualidad: esPuntual state = 'on'.	^ respuesta! !!FormularioEmpresa methodsFor: 'accessing' stamp: 'Ulises 2/25/2023 00:19'!inicializarEmpresa: unGestor	"Mensaje que inicializa el formulario para registrar una empresa"	| contenedor |	"Inicializo los textFieldMorphs propios de la clase"	self		inicializarConAlto: 452		conAncho: 400		conTitulo: 'Formulario Empresa'.	contenedor := self inicializarMorphContenedor: #topToBottom.	contenedor vResizing: #spaceFill.	contenedor addAllMorphs: self crearTextFields.	self addMorph: contenedor.	"Agrego funcionalidad a los botones"	botonCancelar mouseAction: [ self delete ].	botonRegistrar mouseAction: [ self accionBotonRegistrar: unGestor ]! !!FormularioEmpresa methodsFor: 'accessing' stamp: 'Torgeck 2/28/2023 12:43'!inicializarCombinada: unGestor	"Mensaje que inicializa el formulario para registrar una empresa"	| contenedor |	self		inicializarConAlto: 505		conAncho: 400		conTitulo: 'Formulario Empresa combinada'.	"Inicializo los textFieldMorphs propios de la clase"	colProductos := TextFieldMorph new.	contenedor := self inicializarMorphContenedor: #topToBottom.	contenedor vResizing: #spaceFill.	contenedor addAllMorphs: self crearTextFieldsCombinada.	self addMorph: contenedor.	"Agrego funcionalidad a los botones"	botonCancelar mouseAction: [ self delete ].	botonRegistrar mouseAction: [ self accionBotonRegistrar: unGestor ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FormularioEmpresa class	instanceVariableNames: ''!!FormularioEmpresa class methodsFor: 'as yet unclassified' stamp: 'Ulises 2/4/2023 21:54'!crearSolicitante: unGestor	| unFormulario |	unFormulario := self new.	^ unFormulario inicializarSolicitante:  unGestor! !!FormularioEmpresa class methodsFor: 'as yet unclassified' stamp: 'Ulises 2/4/2023 21:54'!crear: unGestor	| unFormulario |	unFormulario := self new.	^ unFormulario inicializarEmpresa:  unGestor! !!FormularioEmpresa class methodsFor: 'as yet unclassified' stamp: 'Ulises 2/4/2023 21:53'!crearCombinada: unGestor	| unFormulario |	unFormulario := self new.	^ unFormulario inicializarCombinada:  unGestor! !Formulario subclass: #FormularioSolicitud	instanceVariableNames: 'fechaVencimineto monto'	classVariableNames: ''	package: 'TPFinalObligatorio'!!FormularioSolicitud methodsFor: 'as yet unclassified' stamp: 'Ulises 2/25/2023 02:31'!crearTextFields	^ OrderedCollection newFrom: { 			  (self				   crearTextFieldMorph: fechaVencimineto				   conLabel: 'Fecha de vencimiento: '				   conGhostText: '03/12/2020').			  (self				   crearTextFieldMorph: monto				   conLabel: 'Monto: '				   conGhostText: '90000') }! !!FormularioSolicitud methodsFor: 'as yet unclassified' stamp: 'Ulises 2/20/2023 00:31'!obtenerFecha: unTextField	"Mensaje que retorna la fecha de un textField en formato dd/mm/aaaa"	^ Date readFrom: unTextField getString pattern: 'd/m/yyyy'! !!FormularioSolicitud methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 12:17'!inicializar	"Mensaje que inicializa los morphs propios de la clase"	fechaVencimineto := TextFieldMorph new.	monto := TextFieldMorph new! !!FormularioSolicitud methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/27/2023 22:01'!accionBotonRegistrar: unGestor conEmpresa: unaEmpresa	"Checkeo si hay textFields sin completar por el usuario"	self hayTextFieldsVacios		ifTrue: [ 			UIManager default				alert: 'Hay uno o mas campos vacios'				title: 'Campos vacios' ]		ifFalse: [ 			self registrar: unGestor conEmpresa: unaEmpresa.			unGestor changed.			self delete ]! !!FormularioSolicitud methodsFor: 'accessing' stamp: 'Ulises 1/28/2023 17:30'!hayTextFieldsVacios "Mensaje que retorna true si el receptor tiene textFields sin llenar por el usuario"^fechaVencimineto getString = '' or: monto getString = ''! !!FormularioSolicitud methodsFor: 'accessing' stamp: 'Ulises 1/29/2023 21:32'!registrar: unGestor conEmpresa: unaEmpresaself subclassResponsibility ! !FormularioSolicitud subclass: #FormularioServicio	instanceVariableNames: 'caracteristicas duracion formaDePago servicioSolicitado'	classVariableNames: ''	package: 'TPFinalObligatorio'!!FormularioServicio methodsFor: 'accessing' stamp: 'Ulises 1/28/2023 21:29'!hayTextFieldsVacios "Mensaje que indica a traves de un boolean si el receptor del mensaje posee textFields vacios, en caso de no estar inicializados se ignora"| respuesta aux |	aux := OrderedCollection withAll: { 			       caracteristicas .			       duracion.			       formaDePago .			       servicioSolicitado  }.	respuesta := aux select: [ :unTextField | 		             unTextField			             ifNotNil: [ unTextField getString = '' ]			             ifNil: false ].	^ super hayTextFieldsVacios or: respuesta isNotEmpty! !!FormularioServicio methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 12:18'!inicializarPuntual	caracteristicas := TextFieldMorph new.	servicioSolicitado := TextFieldMorph new! !!FormularioServicio methodsFor: 'as yet unclassified' stamp: 'Ulises 2/25/2023 01:56'!inicializarPuntual: unGestor conEmpresa: unaEmpresaSol	"Mensaje que inicializa y abre un formulario para registrar un servicio en world"	| contenedor |	"Inicializo los demas submorphs"	self		inicializarConAlto: 305		conAncho: 400		conTitulo: 'Formulario Solicitud de servicio puntual'.	self inicializarPuntual.	"Aniado los submorphs a sus respectivos contenedores"	contenedor := self inicializarMorphContenedor: #topToBottom.	contenedor vResizing: #spaceFill.	contenedor		addAllMorphs: self crearMorphsPuntuales;		addMorphBack: self crearBotonesFormulario.	self addMorph: contenedor.	"Aniado funcionalidad a los botones"	botonCancelar mouseAction: [ self delete ].	botonRegistrar mouseAction: [ 		self accionBotonRegistrar: unGestor conEmpresa: unaEmpresaSol ]! !!FormularioServicio methodsFor: 'as yet unclassified' stamp: 'Ulises 2/25/2023 02:35'!crearMorphsPuntuales	"Mensaje que crea morphs correspondiente a servicio puntual y retorna una coleccion con ellos"	|colMorph|		colMorph := self crearTextFields.	colMorph addAllLast: { 			  (self				   crearTextFieldMorph: caracteristicas				   conLabel: 'Caracteristicas: '				   conGhostText: 'Pintar la pared de...').			  (self				   crearTextFieldMorph: servicioSolicitado				   conLabel: 'Servicio solicitado: '				   conGhostText: 'Reparacion') }.				^colMorph ! !!FormularioServicio methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/27/2023 21:58'!registrar: unGestor conEmpresa: unaEmpresa	| diaActual unVencimiento unMonto unaCaracteristica unServicio |	diaActual := unGestor getDiaActual.	unVencimiento := self obtenerFecha: fechaVencimineto.	unMonto := monto getString asNumber.	unaCaracteristica := caracteristicas getStringUppercase.	unServicio := servicioSolicitado getStringUppercase.	duracion		ifNil: [ 			unaEmpresa				registrarSolicitudServPuntual: diaActual				conFechaVencimiento: unVencimiento				conMonto: unMonto				conCaracteristicas: unaCaracteristica				conServicio: unServicio ]		ifNotNil: [ 			unaEmpresa				registrarSolicitudServUniforme: diaActual				conFechaVencimiento: unVencimiento				conMonto: unMonto				conCaracteristicas: unaCaracteristica				conDuracion: duracion getStringUppercase				conFormaPago: formaDePago getStringUppercase				conServicio: unServicio ].! !!FormularioServicio methodsFor: 'as yet unclassified' stamp: 'Ulises 2/25/2023 01:34'!crearMorphsUniformes	"Mensaje que agrega morphs correspondiente a servicio puntual al receptor del mensaje"	| colMorph |	colMorph := self crearMorphsPuntuales.	colMorph addAllLast: { 			(self				 crearTextFieldMorph: duracion				 conLabel: 'Duracion: '				 conGhostText: '2 años').			(self				 crearTextFieldMorph: formaDePago				 conLabel: 'Forma de pago: '				 conGhostText: 'Mensual') }.	^ colMorph! !!FormularioServicio methodsFor: 'as yet unclassified' stamp: 'Ulises 2/25/2023 02:02'!inicializarUniforme: unGestor conEmpresa: unaEmpresaSol	"Mensaje que inicializa y abre un formulario para registrar un servicio en world"	| contenedor |	self		inicializarConAlto: 405		conAncho: 400		conTitulo: 'Formulario Solicitud de servicio uniforme'.	"Inicializo los demas submorphs"	self inicializarUniforme.	contenedor := self inicializarMorphContenedor: #topToBottom.	contenedor vResizing: #spaceFill.	"Aniado los submorphs a sus respectivos contenedores"	contenedor		addAllMorphs: self crearMorphsUniformes;		addMorphBack: self crearBotonesFormulario.	self addMorph: contenedor.	"Aniado funcionalidad a los botones"	botonCancelar mouseAction: [ self delete ].	botonRegistrar mouseAction: [ 		self accionBotonRegistrar: unGestor conEmpresa: unaEmpresaSol ]! !!FormularioServicio methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 12:18'!inicializarUniforme	self inicializarPuntual.	duracion := TextFieldMorph new.	formaDePago := TextFieldMorph new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FormularioServicio class	instanceVariableNames: ''!!FormularioServicio class methodsFor: 'as yet unclassified' stamp: 'Ulises 2/8/2023 15:01'!crearPuntual: unGestor conEmpresa: unaEmpresa|unFormulario|unFormulario := self new.^unFormulario inicializarPuntual: unGestor conEmpresa:unaEmpresa! !!FormularioServicio class methodsFor: 'as yet unclassified' stamp: 'Ulises 2/8/2023 16:40'!crearUniforme: unGestor conEmpresa: unaEmpresa	| unFormulario |	unFormulario := self new.	^ unFormulario inicializarUniforme: unGestor conEmpresa: unaEmpresa! !FormularioServicio subclass: #FormularioServicioProducto	instanceVariableNames: 'productoSolicitado'	classVariableNames: ''	package: 'TPFinalObligatorio'!!FormularioServicioProducto methodsFor: 'accessing' stamp: 'Ulises 1/29/2023 16:42'!hayTextFieldsVacios ^ super hayTextFieldsVacios or: productoSolicitado getString = ''! !!FormularioServicioProducto methodsFor: 'accessing' stamp: 'Torgeck 2/27/2023 21:59'!registrar: unGestor conEmpresa: unaEmpresa	| diaActual unVencimiento unMonto unaCaracteristica unServicio unProducto |	diaActual := unGestor getDiaActual.	unVencimiento := self obtenerFecha: fechaVencimineto.	unMonto := monto getString asNumber.	unaCaracteristica := caracteristicas getStringUppercase.	unServicio := servicioSolicitado getStringUppercase.	unProducto := productoSolicitado getStringUppercase.	duracion		ifNil: [ 			unaEmpresa				registrarSolServProPuntual: diaActual				conFechaVen: unVencimiento				conMonto: unMonto				conCaracteristicas: unaCaracteristica				conServicio: unServicio				conProducto: unProducto ]		ifNotNil: [ 			unaEmpresa				registrarSolServProUniforme: diaActual				conFechaVen: unVencimiento				conMonto: unMonto				conCaracteristicas: unaCaracteristica				conDuracion: duracion getStringUppercase				conFormaPago: formaDePago getStringUppercase				conServicio: unServicio				conProducto: unProducto ].! !!FormularioServicioProducto methodsFor: 'as yet unclassified' stamp: 'Ulises 2/25/2023 22:48'!crearMorphsPuntuales	| colMorphs |	colMorphs := super crearMorphsPuntuales.	colMorphs addLast: 			(self				 crearTextFieldMorph: productoSolicitado				 conLabel: 'Producto solicitado: '				 conGhostText: 'Pintura').			 	^ colMorphs! !!FormularioServicioProducto methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 12:21'!inicializarPuntual: unGestor conEmpresa: unaEmpresa	"Mensaje que inicializa un formulario de solicitud combinada uniforme "	| contenedor |	self		inicializarConAlto: 355		conAncho: 400		conTitulo: 'Formulario Solicitud puntual combinada'.	self inicializarPuntual.	productoSolicitado := TextFieldMorph new.	contenedor := self inicializarMorphContenedor: #topToBottom.	contenedor vResizing: #spaceFill.	"Agrego los morphs a sus respectivos contenedores"	contenedor		addAllMorphs: self crearMorphsPuntuales;		addMorphBack: self crearBotonesFormulario.	self addMorph: contenedor.	"Agrego funcionalidad a los botones"	botonCancelar mouseAction: [ self delete ].	botonRegistrar mouseAction: [ 		self accionBotonRegistrar: unGestor conEmpresa: unaEmpresa ]! !!FormularioServicioProducto methodsFor: 'as yet unclassified' stamp: 'Ulises 2/25/2023 22:48'!crearMorphsUniformes	| colMorphs |	colMorphs := super crearMorphsUniformes.	^ colMorphs! !!FormularioServicioProducto methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 12:21'!inicializarUniforme: unGestor conEmpresa: unaEmpresa	"Mensaje que inicializa un formulario de solicitud combinada uniforme "	| contenedor |	self		inicializarConAlto: 460		conAncho: 400		conTitulo: 'Formulario Solicitud uniforme combinada'.	self inicializarUniforme.	productoSolicitado := TextFieldMorph new.	contenedor := self inicializarMorphContenedor: #topToBottom.	contenedor vResizing: #spaceFill.	"Agrego los morphs propios de la clase"	contenedor		addAllMorphs: self crearMorphsUniformes;		addMorphBack: self crearBotonesFormulario.	self addMorph: contenedor.	"Agrego funcionalidad a los botones"	botonCancelar mouseAction: [ self delete ].	botonRegistrar mouseAction: [ 		self accionBotonRegistrar: unGestor conEmpresa: unaEmpresa ]! !FormularioSolicitud subclass: #FormularioTrabajo	instanceVariableNames: 'cargo descripcion'	classVariableNames: ''	package: 'TPFinalObligatorio'!!FormularioTrabajo methodsFor: 'accessing' stamp: 'Torgeck 2/27/2023 21:59'!registrar: unGestor conEmpresa: unaEmpresa	unaEmpresa		registrarSolicitudTrabajo: unGestor getDiaActual		conFechaVen: (self obtenerFecha: fechaVencimineto)		conMonto: monto getText asNumber		conCargo: cargo getStringUppercase		conDescripcion: descripcion getString.! !!FormularioTrabajo methodsFor: 'as yet unclassified' stamp: 'Ulises 2/25/2023 02:33'!crearTextFields	| colMorphs |	colMorphs := super crearTextFields.	colMorphs addAllLast: { 			(self				 crearTextFieldMorph: cargo				 conLabel: 'Cargo: '				 conGhostText: 'Panadero').			(self				 crearTextFieldMorph: descripcion				 conLabel: 'Descripcion: '				 conGhostText:				 'Realizar la planificación diaria de las tareas de producción del sector panadería.').			self crearBotonesFormulario }.	^ colMorphs! !!FormularioTrabajo methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 12:27'!inicializar: unGestor conEmpresa: unaEmpresa	| contenedor |	self		inicializarConAlto: 305		conAncho: 400		conTitulo: 'Formulario Solicitud de trabajo'.		"Creo los submorphs propios de la clase"	contenedor := self inicializarMorphContenedor: #topToBottom.	contenedor vResizing: #spaceFill.	"Agrego los submorphs a los contenedores correspondientes"	contenedor addAllMorphs: self crearTextFields.	self addMorph: contenedor.	"Agrego funcionalidad a los botones"	botonCancelar mouseAction: [ self delete ].	botonRegistrar mouseAction: [ 		self accionBotonRegistrar: unGestor conEmpresa: unaEmpresa ]! !!FormularioTrabajo methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 12:22'!inicializar super inicializar.cargo := TextFieldMorph new.	descripcion := TextFieldMorph new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FormularioTrabajo class	instanceVariableNames: ''!!FormularioTrabajo class methodsFor: 'as yet unclassified' stamp: 'Ulises 2/9/2023 14:52'!crear: unGestor conEmpresa: unaEmpresa	| unFormulario |	unFormulario := self new.	^ unFormulario inicializar: unGestor conEmpresa: unaEmpresa! !Ventana subclass: #GestorEmpleosVisual	instanceVariableNames: 'morphTabla morphBotonera botonRegistro botonPropuesta botonListados botonIniciarDia fecha'	classVariableNames: ''	package: 'TPFinalObligatorio'!!GestorEmpleosVisual methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/27/2023 23:21'!inicializar: unGestor	| colBotones morphContenedor |	" Inicializo la ventana con un alto y ancho default "	self		inicializarConAlto: 240		conAncho: 800		conTitulo: 'Gestor Empleos'.	morphContenedor := self inicializarMorphContenedor: #leftToRight.	morphContenedor vResizing: #spaceFill.	colBotones := self crearBotonesUniformes.	unGestor addDependent: self.	fecha := self crearStringMorph: unGestor getDiaActual asString.	colBotones insert: fecha before: 4.	"Creo e inicializo los morphs que van a ir dentro de mi morphContenedor"	self inicializarBotoneraCon: colBotones.	self inicializarTabla: unGestor.	"Agrego los morphs anteriores a mi morphContenedor"	morphContenedor		addMorph: morphBotonera;		addMorph: morphTabla.	"Agrego el morph contenedor a gestorEmpleoVisual"	self addMorph: morphContenedor.	"Aniado funcionalidad a los botones"	botonRegistro mouseAction: [ self accionBotonRegistro: unGestor ].	botonPropuesta mouseAction: [ self accionBotonPropuesta: unGestor ].	botonListados mouseAction: [ self accionBotonListados: unGestor ].	botonIniciarDia mouseAction: [ self accionBotonIniciarDia: unGestor ]! !!GestorEmpleosVisual methodsFor: 'as yet unclassified' stamp: 'Ulises 1/31/2023 00:33'!accionBotonIniciarDia: unGestor	unGestor   iniciarDia.		unGestor  changed! !!GestorEmpleosVisual methodsFor: 'as yet unclassified' stamp: 'Ulises 2/26/2023 00:49'!inicializarBotoneraCon: unaColBot	"Metodo que crea una botonera para la clase GestorEmpleosVisual "	morphBotonera := self inicializarMorphContenedor: #topToBottom.	morphBotonera		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		addAllMorphs: unaColBot	! !!GestorEmpleosVisual methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2023 01:24'!crearBotonesUniformes	| colBoton |		colBoton := OrderedCollection withAll: { 			            botonRegistro := Boton newWithLabel: 'Registrar'.	botonPropuesta := Boton newWithLabel: 'Propuestas'.	botonListados := Boton newWithLabel: 'Generar Listados'.	botonIniciarDia := Boton newWithLabel: 'Iniciar Dia'. }.	^ self redimensionarBotones: colBoton! !!GestorEmpleosVisual methodsFor: 'as yet unclassified' stamp: 'Ulises 2/18/2023 23:51'!accionBotonListados: unGestor	VentanaListados crear: unGestor.	! !!GestorEmpleosVisual methodsFor: 'as yet unclassified' stamp: 'Ulises 2/7/2023 20:40'!accionBotonRegistro: miGestor	| opcion |	opcion := UIManager default		          chooseFrom:		          { 'Registrar postulantes'. 'Registrar solicitudes / empresas solicitantes ' }		          lines: { 1 }		          message: '¿Que desea registrar?'		          title: 'Registrar'.	"Segun la opcion abro una ventana con postulantes + 1 tabla o solicitantes + 2 tablas"	opcion ~= 0 ifTrue: [ 		opcion = 1			ifTrue: [ VentanaPostulante crear: miGestor ]			ifFalse: [ VentanaSolicitante crear: miGestor ] ]! !!GestorEmpleosVisual methodsFor: 'as yet unclassified' stamp: 'Ulises 2/20/2023 01:30'!accionBotonPropuesta: unGestor VentanaPropuestas crear: unGestor! !!GestorEmpleosVisual methodsFor: 'as yet unclassified' stamp: 'Ulises 2/6/2023 19:33'!inicializarTabla: unGestor	"Mensaje que crea e inicializa tabla con 2 columnas y 3 filas, para mostrar la cantidad de postulantes, propuestas y solicitantes que tiene el gestor actualmente"	| unaCol |	unaCol := OrderedCollection withAll: { 			          unGestor getColPostulantes.			          unGestor getColPropuestas.			          unGestor getColSolicitantes }.	morphTabla := FTTableMorph new.	morphTabla		initialize;		hResizing: #spaceFill;		vResizing: #spaceFill;		addColumn: (FTColumn id: 'Coleccion');		addColumn: (FTColumn id: 'Cantidad').	morphTabla dataSource: (FTGestorEmpleosDataSource elements: unaCol)! !!GestorEmpleosVisual methodsFor: 'as yet unclassified' stamp: 'Ulises 2/18/2023 23:11'!inicializar	| colBotones morphContenedor miGestor |	" Inicializo la ventana con un alto y ancho default "	self		inicializarConAlto: 225		conAncho: 800		conTitulo: 'Gestor Empleos'.	morphContenedor := self inicializarMorphContenedor: #leftToRight.	colBotones := self crearBotonesUniformes.	miGestor := GestorEmpleos crear.	miGestor addDependent: self.	fecha := StringMorph contents: miGestor getDiaActual asString.	colBotones insert: fecha before: 4.	"Creo e inicializo los morphs que van a ir dentro de mi morphContenedor"	self inicializarBotoneraCon: colBotones.	self inicializarTabla: miGestor.	"Agrego los morphs anteriores a mi morphContenedor"	morphContenedor		addMorph: morphBotonera;		addMorph: morphTabla.	"Agrego el morph contenedor a gestorEmpleoVisual"	self addMorph: morphContenedor.	"Aniado funcionalidad a los botones"	botonRegistro mouseAction: [ self accionBotonRegistro: miGestor ].	botonPropuesta mouseAction: [ self accionBotonPropuesta: miGestor ].	botonListados mouseAction: [ self accionBotonListados: miGestor ].	botonIniciarDia mouseAction: [ self accionBotonIniciarDia: miGestor ]! !!GestorEmpleosVisual methodsFor: 'updating' stamp: 'Ulises 2/3/2023 21:44'!update: unObjeto	morphTabla refresh.	fecha contents: unObjeto getDiaActual asString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GestorEmpleosVisual class	instanceVariableNames: ''!!GestorEmpleosVisual class methodsFor: 'as yet unclassified' stamp: 'Ulises 2/4/2023 22:01'!crear	|gestor|	gestor := self new.	^ gestor inicializar.! !Ventana subclass: #VentanaListados	instanceVariableNames: 'morphLista morphTituloTabla botonSolicitudesPendientes botonSolicitudesAtendidas botonEmpresasSolicitantes'	classVariableNames: ''	package: 'TPFinalObligatorio'!!VentanaListados methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 01:06'!inicializar: unGestor	"Mensaje que inicializa una ventana para mostrar distintos listados del gestor pasado por argumento al usuario"	| contenedor botonera contenedorTabla colBot |	self inicializarConAlto: 500 conAncho: 1500 conTitulo: 'Listados'.	"Creo e inicializo los distintos contenedores"	contenedor := self inicializarMorphContenedor: #leftToRight.	contenedor vResizing: #spaceFill.	botonera := self inicializarMorphContenedor: #topToBottom.	botonera hResizing: #shrinkWrap.	contenedorTabla := self inicializarMorphContenedor: #topToBottom.	contenedorTabla vResizing: #spaceFill.	"Me aniado como dependiente del gestor"	unGestor addDependent: self.	"Creo e inicializo los morphs"	colBot := self crearBotonesUniformes.	morphLista := FTTableMorph new.	morphLista		initialize;		hResizing: #spaceFill;		vResizing: #spaceFill;		intercellSpacing: 1.	morphTituloTabla := self crearStringMorph:		                    'Elija que mostrar en la tabla'.	"Aniado los morphs a sus respectivos contenedores"	self addMorph: contenedor.	contenedor addAllMorphs: { 			contenedorTabla.			botonera }.	contenedorTabla addAllMorphs: { 			morphTituloTabla.			morphLista }.	botonera addAllMorphs: colBot.	"Aniado funcionalidad a los botones"	botonSolicitudesPendientes mouseAction: [ 		self accionBotonSolicitudesPendientes: unGestor ].	botonSolicitudesAtendidas mouseAction: [ 		self accionBotonSolicitudesAtendidas: unGestor ].	botonEmpresasSolicitantes mouseAction: [ 		self accionBotonEmpresasSolicitantes: unGestor ]! !!VentanaListados methodsFor: 'as yet unclassified' stamp: 'Ulises 2/19/2023 21:19'!crearBotonesUniformes	| colBot |	colBot := OrderedCollection withAll: { 			          (botonSolicitudesPendientes := Boton newWithLabel: 'Solicitudes Pendientes').			          (botonSolicitudesAtendidas := Boton newWithLabel: 'Solicitudes Atendidas').			          (botonEmpresasSolicitantes := Boton newWithLabel: 'Empresas Solicitantes') }.	^ self redimensionarBotones: colBot! !!VentanaListados methodsFor: 'as yet unclassified' stamp: 'Ulises 2/20/2023 00:41'!listarPorFecha: unGestor	"Mensaje que cambia el titulo de la tabla y el data source de la misma a solicitudes registradas en una fecha dada por el usuario"	| unaFecha |	unaFecha := Date		            readFrom: (UIManager default				             textEntry: 'Ingrese una fecha'				             title: 'Listado de solicitudes por fecha'				             entryText: 'dd/mm/aaaa')		            pattern: 'd/m/yyyy'.	morphLista dataSource: (FTSolicitudesDataSource elements:			 (unGestor listarSolicitudesPendientesRegistradas: unaFecha)).	morphTituloTabla contents:		'Listado de solicitudes registradas en la fecha: '		, unaFecha asString! !!VentanaListados methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 12:39'!accionBotonEmpresasSolicitantes: unGestor	"Muestra las empresas solicitantes de mayor a menor segun cuantas solicitudes tengan resueltas"	morphLista columns: { 			((FTColumn id: 'ID') width: 20).			(FTColumn id: 'Nombre').			((FTColumn id: 'N° Solicitudes resueltas') width: 140).			((FTColumn id: 'N° Solicitudes') width: 120) }.	morphLista dataSource: (FTEmpresasSolicitantesDataSource elements:			 unGestor listarEmpresasSolResueltas).	morphTituloTabla contents:		'Empresas solicitantes ordenadas por cantidad de solicitudes resueltas'! !!VentanaListados methodsFor: 'as yet unclassified' stamp: 'Ulises 2/20/2023 00:57'!listarPorEmpresa: unGestor	"Podria hacer mi custom lista mas ventana y que eso devuelva la empresa que selecciono el usuario, pero no sabria como utilizar o si es que se puede el resultado de otro morph"	| unaColEmpresa unaColNombres unaEmpresa |	unaColEmpresa := unGestor getColSolicitantes.	unaColNombres := unaColEmpresa collect: [ :unaEmp | unaEmp getNombre ].	unaEmpresa := UIManager default		              chooseFrom: unaColNombres		              values: unaColEmpresa		              message: 'Seleccione una empresa'		              title: 'Listado de solicitudes por empresa'.unaEmpresa ifNotNil: [  	morphLista dataSource: (FTSolicitudesDataSource elements:			 (unGestor listarSolicitudesPendientes: unaEmpresa)).	morphTituloTabla contents:		'Listado de solicitudes de la empresa: ' , unaEmpresa getNombre]! !!VentanaListados methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 01:01'!accionBotonSolicitudesPendientes: unGestor	"Le doy a legir dos opciones al usuario"	| opcion |	self cambiarColumnasSolicitudes: morphLista .	opcion := UIManager default		          chooseFrom:		          { 'Realizadas por una Empresa'.		          'Registradas en una fecha dada' }		          lines: #( 1 )		          message: 'Solicitudes pendientes: '		          title: 'Opciones de listados a generar'.	opcion ~= 0 ifTrue: [ 		opcion = 1			ifTrue: [ self listarPorEmpresa: unGestor ]			ifFalse: [ self listarPorFecha: unGestor ] ]! !!VentanaListados methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 01:01'!accionBotonSolicitudesAtendidas: unGestor	"Mensaje que hace display de las solicitudes que han sido atendidas con toda la info "	self cambiarColumnasSolicitudes: morphLista .	morphLista dataSource:		(FTSolicitudesDataSource elements:			 unGestor listarSolicitudesResueltas).	morphTituloTabla contents: 'Listado de solicitudes atendidas'! !Ventana subclass: #VentanaPostulante	instanceVariableNames: 'morphTabla botonPersona botonEmpresaServicio botonEmpresaCombinada'	classVariableNames: ''	package: 'TPFinalObligatorio'!!VentanaPostulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/6/2023 19:33'!inicializar: miGestor	"Mensaje que inicializa ventana para mostrar y registrar postulantes al gestor pasado por parametro"	| contenedor contenedorBotones colBotones |	self		inicializarConAlto: 300		conAncho: 800		conTitulo: 'Registro Postulantes'.	contenedor := self inicializarMorphContenedor: #leftToRight.	contenedor vResizing: #spaceFill.	contenedorBotones := self inicializarBotonera: #topToBottom.	"Me aniado como dependiente del gestor"	miGestor addDependent: self.	"Creo los botones y la tabla"	colBotones := self crearBotonesUniformes.	contenedorBotones addAllMorphs: colBotones.	self inicializarTabla: miGestor.	"Agrego los morphs al contenedor"	contenedor		addMorph: contenedorBotones;		addMorph: morphTabla.	"Aniado el conetenedor a mi mismo"	self addMorph: contenedor.	"Agrego las funcionalidades de los botones"	botonPersona mouseAction: [ FormularioPersona crear: miGestor ].	botonEmpresaServicio mouseAction: [ 		FormularioEmpresa crear: miGestor ].	botonEmpresaCombinada mouseAction: [ 		FormularioEmpresa crearCombinada: miGestor ]! !!VentanaPostulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/27/2023 15:39'!inicializarTabla: unGestor	"Mensaje que crea e inicializa una tabla con x columnas y n filas, para mostrar los postulantes y sus tipos que tiene el gestor"	morphTabla := FTTableMorph new.	morphTabla		initialize;		hResizing: #spaceFill;		vResizing: #spaceFill;		addColumn: ((FTColumn id: 'ID') width: 20);		addColumn: (FTColumn id: 'Nombre');		addColumn: (FTColumn id: 'Tipo');		intercellSpacing: 1.	"Ver si aniado mas columnas con mas detalles o no"	morphTabla dataSource:		(FTPostulantesDataSource elements: unGestor getColPostulantes)! !!VentanaPostulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/27/2023 15:54'!inicializarBotonera: unaDireccion	"Crear e inicializar una botonera"	| unMorph unStringMorph|	"Creo e inicializo el subtitulo de"	unStringMorph := self crearStringMorph: 'Registrar'.		unMorph := self inicializarMorphContenedor: unaDireccion.	unMorph		hResizing: #shrinkWrap;		addMorph: unStringMorph .	^ unMorph! !!VentanaPostulante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/19/2023 21:11'!crearBotonesUniformes	"Mensaje que crea los botones propios de la clase"	| colBot |		colBot := OrderedCollection withAll: { 			          botonPersona := Boton newWithLabel: 'Persona'.	botonEmpresaServicio := Boton newWithLabel: 'Empresa Servicio'.	botonEmpresaCombinada := Boton newWithLabel: 'Empresa Combinada'. }.	^ self redimensionarBotones: colBot! !!VentanaPostulante methodsFor: 'updating' stamp: 'Ulises 2/4/2023 22:15'!update: unObjeto	morphTabla refresh.! !Ventana subclass: #VentanaPropuestas	instanceVariableNames: 'tablaPropuestas botonGenerarPropuestas botonAceptarPropuesta botonFraude'	classVariableNames: ''	package: 'TPFinalObligatorio'!!VentanaPropuestas methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 01:30'!inicializar: unGestor	"Mensaje que inicializa una ventana para ver/aceptar propuestas y hacer el control de fraude"	| contenedor botonera colBot |	self inicializarConAlto: 300 conAncho: 1500 conTitulo: 'Propuestas'.	"Inicializo los contenedores"	contenedor := self inicializarMorphContenedor: #leftToRight.	contenedor vResizing: #spaceFill.	botonera := self inicializarMorphContenedor: #topToBottom.	botonera hResizing: #shrinkWrap.	"Me aniado como dependiente del gestor"	unGestor addDependent: self.	"Creo e inicializo los morphs"	colBot := self crearBotonesUniformes.	self inicializarTabla: unGestor.	"Agrego los morphs a sus respectivos contenedores"	contenedor addAllMorphs: { 			tablaPropuestas.			botonera }.	botonera addAllMorphs: colBot.	self addMorph: contenedor.	"Agrego funcionalidad a los botones"	botonGenerarPropuestas mouseAction: [ 		self accionBotonGenerarPropuestas: unGestor ].	botonAceptarPropuesta mouseAction: [ 		self accionBotonAceptarPropuesta: unGestor ].	botonFraude mouseAction: [ self accionBotonFraude: unGestor ]! !!VentanaPropuestas methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/27/2023 22:54'!accionBotonAceptarPropuesta: unGestor	| indice unaPropuesta |	indice := tablaPropuestas selectedIndex.	indice = 0		ifTrue: [ 			UIManager default				alert: 'No se encuentra seleccionada una propuesta'				title: 'Alerta' ]		ifFalse: [ 			unaPropuesta := tablaPropuestas dataSource elementAt: indice.			(unGestor aceptarPropuesta: unaPropuesta) ifFalse: [ UIManager default alert: 'La propuesta seleccionada es un fraude' title: 'Alerta' ] ].	unGestor changed! !!VentanaPropuestas methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2023 01:25'!crearBotonesUniformes	| colBoton |	colBoton := OrderedCollection withAll: { 			            (botonAceptarPropuesta   := Boton newWithLabel: 'Aceptar propuesta').			            (botonFraude  := Boton newWithLabel: 'Control de fraude').			            (botonGenerarPropuestas  := Boton newWithLabel:				                              'Generar propuestas').			            }.	^ self redimensionarBotones: colBoton! !!VentanaPropuestas methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/27/2023 22:15'!accionBotonFraude: unGestor	"Mensaje elimina y avisa al ususario si se ah ocurrido un fraude"	| cantidadFraudes |	cantidadFraudes := unGestor controlFraude.	unGestor changed.	UIManager default		alert: 'Fraude/s eliminado/s: ' , cantidadFraudes asString		title: 'Alerta'.	! !!VentanaPropuestas methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/27/2023 19:10'!accionBotonGenerarPropuestas: unGestor	unGestor generarPropuestasPendientes.	unGestor changed! !!VentanaPropuestas methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 01:28'!inicializarTabla: unGestor	tablaPropuestas := FTTableMorph new.	tablaPropuestas		initialize;		hResizing: #spaceFill;		vResizing: #spaceFill;		columns: { 				(FTColumn id: 'Descripcion Solicitud').				((FTColumn id: 'Monto')width: 60).				((FTColumn id: 'Postulante')width: 120).				((FTColumn id: 'Tipo')width:120).				((FTColumn id: 'Fecha de registro')width:120).				((FTColumn id: 'Vencimiento')width: 120) };		intercellSpacing: 1.	tablaPropuestas dataSource:		(FTPropuestasDataSource elements: unGestor getPropuestas)! !!VentanaPropuestas methodsFor: 'updating' stamp: 'Torgeck 2/28/2023 00:35'!update: unObjeto	tablaPropuestas refresh; deselectAll.! !Ventana subclass: #VentanaSolicitante	instanceVariableNames: 'morphTablaEmpresas morphTablaSolicitudes botonEmpresa botonSolicitud botonRevalidar botonVerSolicitudes'	classVariableNames: ''	package: 'TPFinalObligatorio'!!VentanaSolicitante methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 01:20'!inicializar: unGestor	"Mensaje que inicializa ventana para ver/registrar empresas solicitantes y solicitudes"	| contenedor contenedorTablas contenedorBotones colBot |	self		inicializarConAlto: 500		conAncho: 1500		conTitulo: 'Registro Solicitantes'.	"Creo e inicializo los botones"	contenedor := self inicializarMorphContenedor: #leftToRight.	contenedor vResizing: #spaceFill.	contenedorTablas := self inicializarMorphContenedor: #topToBottom.	contenedorTablas vResizing: #spaceFill.	contenedorBotones := self inicializarMorphContenedor: #topToBottom.	contenedorBotones		hResizing: #shrinkWrap;		vResizing: #spaceFill.	"Me aniado como dependiente del gestor"	unGestor addDependent: self.	"Creo los botones y tablas"	colBot := self crearBotonesUniformes.	self inicializarTablaEmpresas: unGestor.	self inicializarTablaSolicitudes: unGestor.	"Aniado los morphs a sus respectivos contenedores"	contenedor addAllMorphs: { 			contenedorTablas.			contenedorBotones }.	contenedorTablas addAllMorphs: { 			morphTablaEmpresas.			morphTablaSolicitudes }.	contenedorBotones addAllMorphs: colBot.	self addMorph: contenedor.	"Aniado funcionalidad a los botones "	botonEmpresa mouseAction: [ FormularioSolicitante crear: unGestor ].	botonSolicitud mouseAction: [ self accionBotonSolicitud: unGestor ].	botonRevalidar mouseAction: [ self accionBotonRevalidar: unGestor ].	botonVerSolicitudes mouseAction: [ 		self accionBotonVerSolicitudes: unGestor ]! !!VentanaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/16/2023 16:38'!cambiarDataSourceTablaSolicitudes: unGestor	"Mensaje que cambia el dataSource de morphTabla empresa"	| indice |	indice := morphTablaEmpresas selectedIndex.	indice = 0		ifFalse: [ 			morphTablaSolicitudes dataSource:				(FTSolicitudesDataSource elements:					 (unGestor getColSolicitantes at: indice) getColSolicitudes) ]		ifTrue: [ 			morphTablaSolicitudes dataSource:				(FTSolicitudesDataSource elements: {  }) ]! !!VentanaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/21/2023 01:11'!inicializarTablaEmpresas: unGestor	"Mensaje que crea e inicializa una tabla con x columnas y n filas, para mostrar las empresas solicitantes y sus caracteristicas en el gestor "	morphTablaEmpresas := FTTableMorph new.	morphTablaEmpresas		initialize;		beResizable;		hResizing: #spaceFill;		vResizing: #spaceFill;		columns: { 				((FTColumn id: 'ID') width: 20).				(FTColumn id: 'Nombre').				((FTColumn id: 'N° Solicitudes') width: 90).				((FTColumn id: 'N° Solicitudes resueltas') width: 140) };		intercellSpacing: 1.	"Ver si aniado mas columnas con mas detalles o no"	morphTablaEmpresas dataSource:		(FTEmpresasSolicitantesDataSource elements:			 unGestor getColSolicitantes)! !!VentanaSolicitante methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 01:04'!inicializarTablaSolicitudes: unGestor	"Mensaje que crea e inicializa una tabla con x columnas y n filas, para mostrar las empresas solicitantes y sus caracteristicas en el gestor "	morphTablaSolicitudes := FTTableMorph new.	morphTablaSolicitudes		initialize;		hResizing: #spaceFill;		vResizing: #spaceFill;		intercellSpacing: 1;		beResizable.		self cambiarColumnasSolicitudes: morphTablaSolicitudes.	morphTablaEmpresas addDependent: unGestor.	"Ver si aniado mas columnas con mas detalles o no"	self cambiarDataSourceTablaSolicitudes: unGestor! !!VentanaSolicitante methodsFor: 'as yet unclassified' stamp: 'Torgeck 2/28/2023 12:25'!mostrarOpciones	"Mensaje que muestra las opciones para registrar solicitudes puntuales y devuelve el valor elegido"	| valor |	valor := UIManager default		         chooseFrom:			         { 'Solicitud de SERVICIO PUNTUAL'.			         'Solicitud de SERVICIO Y PRODUCTO PUNTUAL'.			         'Solicitud de SERVICIO UNIFORME'.			         'Solicitud de SERVICIO Y PRODUCTO UNIFORME'.			         'Solicitud de TRABAJO' }		         lines: #( 2 4 )		         message: 'Seleccione el tipo de solicitud'		         title: 'Opciones solicitud'.	^ valor! !!VentanaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/19/2023 21:11'!crearBotonesUniformes	"Mensaje que crea e inicializa botones propios de la clase, retorna una coleccion de botones"	| colBot |		colBot := OrderedCollection withAll: { 			          botonEmpresa := Boton newWithLabel: 'Registrar Empresa'.	botonVerSolicitudes := Boton newWithLabel: 'Mostrar Solicitudes'.	botonSolicitud := Boton newWithLabel: 'Registrar Solicitud'.	botonRevalidar := Boton newWithLabel: 'Revalidar Solicitud'.}.	^ self redimensionarBotones: colBot! !!VentanaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/13/2023 20:29'!accionBotonSolicitud: unGestor	"Mensaje que despliega un formulario en caso de tener una empresa seleccionada en la tabla empresas, caso contrario advierte al usuario que no hay empresas seleccionadas"	| indice opcion formularios |	indice := morphTablaEmpresas selectedIndex.	indice = 0		ifTrue: [ 			UIManager default				alert:				'No hay empresa solicitante seleccionada en la tabla de empresas'				title: 'ATENCION' ]		ifFalse: [ 			formularios := self				               inicializarDiccionario: unGestor				               conEmpresa:				               (morphTablaEmpresas dataSource elementAt: indice).				self cambiarDataSourceTablaSolicitudes: unGestor.			opcion := self mostrarOpciones.			(formularios at: opcion) value ]! !!VentanaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/24/2023 01:16'!accionBotonRevalidar: unGestor	| unaSolicitud cantDias indice |	indice := morphTablaSolicitudes selectedIndex.	indice = 0		ifTrue: [ 			UIManager default				alert: 'No se encuentra seleccionada una solicitud'				title: 'Alerta' ]		ifFalse: [ 			unaSolicitud := morphTablaSolicitudes dataSource elementAt: indice.			unaSolicitud estaVencida				ifTrue: [ 					cantDias := UIManager default						            textEntry:						            'Ingrese la cantidad de dias que desea extender la solicitud'						            title: 'Revalidar solicitud'.					unaSolicitud extenderFechaVencimiento: cantDias asNumber ]				ifFalse: [ 					UIManager default						alert: 'La solicitud seleccionada no se encuentra vencida'						title: 'Alerta' ] ].				unGestor changed.! !!VentanaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/16/2023 16:02'!accionBotonVerSolicitudes: unGestor self cambiarDataSourceTablaSolicitudes: unGestor! !!VentanaSolicitante methodsFor: 'as yet unclassified' stamp: 'Ulises 2/13/2023 20:28'!inicializarDiccionario: unGestor conEmpresa: unaEmpresa	"Mensaje que retorna un diccionario con opciones para mostrar diferentes formularios"	| unDiccionario |	unDiccionario := Dictionary		                 newFromKeys: #( 1 2 3 4 5 0)		                 andValues: { 				                 [ 				                 FormularioServicio					                 crearPuntual: unGestor					                 conEmpresa: unaEmpresa ].				                 [ 				                 FormularioServicioProducto					                 crearPuntual: unGestor					                 conEmpresa: unaEmpresa ].				                 [ 				                 FormularioServicio					                 crearUniforme: unGestor					                 conEmpresa: unaEmpresa ].				                 [ 				                 FormularioServicioProducto					                 crearUniforme: unGestor					                 conEmpresa: unaEmpresa ].				                 [ 				                 FormularioTrabajo					                 crear: unGestor					                 conEmpresa: unaEmpresa ].				nil }.	^ unDiccionario! !!VentanaSolicitante methodsFor: 'updating' stamp: 'Ulises 2/24/2023 01:15'!update: unObjeto	morphTablaEmpresas refresh.	self cambiarDataSourceTablaSolicitudes: unObjeto! !DeServicio subclass: #YProducto	instanceVariableNames: 'productoSolicitado'	classVariableNames: ''	package: 'TPFinalObligatorio'!!YProducto methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/20/2022 05:28'!inicializarPuntual: unaFecha conFechaVen: unaFechaVen conMonto: unMonto conCaracteristicas: unaCarac   conServicio: unServicio conProducto: unProducto	self		inicializarPuntual: unaFecha		conFechaVen: unaFechaVen		conMonto: unMonto		conCaracteristicas: unaCarac		conServicio: unServicio.	productoSolicitado := unProducto! !!YProducto methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/20/2022 05:32'!inicializarUniforme: unaFecha conFechaVen: unaFechaVen conMonto: unMonto conCaracteristicas: unaCarac conDuracion: unaDuracion conFormaPago: unaForma conServicio: unServicio conProducto: unProducto	self		inicializarUniforme: unaFecha		conFechaVen: unaFechaVen		conMonto: unMonto		conCaracteristicas: unaCarac		conDuracion: unaDuracion		conFormaPago: unaForma		conServicio: unServicio.	productoSolicitado := unProducto! !!YProducto methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/20/2022 05:22'!inicializar: unaFecha  conFechaVen: unaFechaVen conEstado: unEstado conMonto: unMonto  conCaracteristicas: unaCarac  conDuracion: unaDuracion conFormaPago: unaForma  conServicio: unServicio conProducto: unProductoself inicializar: unaFecha  conFechaVen: unaFechaVen  conEstado: unEstado   conMonto: unMonto  conCaracteristicas: unaCarac  conDuracion: unaDuracion   conFormaPago: unaForma   conServicio: unServicio .productoSolicitado := unProducto .! !!YProducto methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/22/2022 23:15'!obtenerPostulantesValidos: unaColPostulantes 	"Mensaje que obtiene y retorna una coleccion de postulantes validos para la solicitud de servicio combinada"	|unaPuntualidad|		unaPuntualidad := self esPuntual.	^ unaColPostulantes select: [ :unPostulante | 		  unPostulante esCombinada and: [ 			  (unPostulante tieneProducto: productoSolicitado) and: [ 				  self					  verificarPostulanteValido: unPostulante					  conPuntualidad: unaPuntualidad ] ] ]! !!YProducto methodsFor: 'as yet unclassified' stamp: 'Torgeck 7/22/2022 23:10'!verificarPostulanteValido: unPostulante conPuntualidad: unaPuntualidad	| respuesta |	respuesta := false.	unPostulante esCombinada ifTrue: [ 		(unPostulante tieneProducto: productoSolicitado) ifTrue: [ 			respuesta := super verificarPostulanteValido: unPostulante conPuntualidad: unaPuntualidad ] ].	^ respuesta! !!YProducto methodsFor: 'as yet unclassified' stamp: 'Ulises 2/6/2023 23:32'!getTipo	^ super getTipo , ' y producto'! !!YProducto methodsFor: 'printing' stamp: 'Torgeck 7/23/2022 00:03'!toString	^ super toString , 'Producto solicitado: ' , productoSolicitado! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!YProducto class	instanceVariableNames: ''!!YProducto class methodsFor: 'as yet unclassified' stamp: 'Ulises 1/29/2023 19:24'!crearUniforme: unaFecha conFechaVen: unaFechaVen conMonto: unMonto conCaracteristicas: unaCarac conDuracion: unaDuracion conFormaPago: unaForma conServicio: unServicio conProducto: unProducto|unaSolServPro|unaSolServPro := self new.^unaSolServPro inicializarUniforme: unaFecha conFechaVen: unaFechaVen conMonto: unMonto conCaracteristicas: unaCarac conDuracion: unaDuracion conFormaPago: unaForma conServicio: unServicio conProducto: unProducto! !!YProducto class methodsFor: 'as yet unclassified' stamp: 'Ulises 1/29/2023 19:25'!crearPuntual: unaFecha conFechaVen: unaFechaVen conMonto: unMonto conCaracteristicas: unaCarac conServicio: unServicio conProducto: unProducto	| unaSolServPro |	unaSolServPro := self new.	^ unaSolServPro		  inicializarPuntual: unaFecha		  conFechaVen: unaFechaVen		  conMonto: unMonto		  conCaracteristicas: unaCarac		  conServicio: unServicio		  conProducto: unProducto! !